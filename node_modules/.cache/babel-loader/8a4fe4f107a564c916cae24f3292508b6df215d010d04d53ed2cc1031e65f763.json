{"ast":null,"code":"// Sequence parser combinator\nfunction s(sequence) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref) {\n    let {\n      index = 0,\n      input\n    } = _ref;\n    let position = index;\n    const ast = [];\n    for (const parser of sequence) {\n      const result = parser({\n        index: position,\n        input\n      });\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n    return {\n      success: true,\n      ast: post(ast),\n      index: position,\n      input\n    };\n  };\n}\n\n// Alternative parser combinator\nfunction a(alternative) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref2) {\n    let {\n      index = 0,\n      input\n    } = _ref2;\n    for (const parser of alternative) {\n      const result = parser({\n        index,\n        input\n      });\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Many parser combinator\nfunction m(many) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref3) {\n    let {\n      index = 0,\n      input\n    } = _ref3;\n    let result = {};\n    let position = index;\n    const ast = [];\n    do {\n      result = many({\n        index: position,\n        input\n      });\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n    if (ast.length > 0) {\n      return {\n        success: true,\n        ast: post(ast),\n        index: position,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index: position,\n        input\n      };\n    }\n  };\n}\n\n// Optional parser combinator\nfunction o(optional) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref4) {\n    let {\n      index = 0,\n      input\n    } = _ref4;\n    const result = optional({\n      index,\n      input\n    });\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input\n      };\n    } else {\n      return {\n        success: true,\n        ast: post(null),\n        index,\n        input\n      };\n    }\n  };\n}\n\n// Lookahead parser combinator\nfunction l(lookahead) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref5) {\n    let {\n      index = 0,\n      input\n    } = _ref5;\n    const result = lookahead.do({\n      index,\n      input\n    });\n    if (result.success) {\n      const resultNext = lookahead.next({\n        index: result.index,\n        input\n      });\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Negative parser combinator\nfunction n(negative) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v;\n  return function (_ref6) {\n    let {\n      index = 0,\n      input\n    } = _ref6;\n    const result = negative.do({\n      index,\n      input\n    });\n    if (result.success) {\n      const resultNot = negative.not({\n        index,\n        input\n      });\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input\n        };\n      }\n    }\n    return {\n      success: false,\n      ast: null,\n      index,\n      input\n    };\n  };\n}\n\n// Token parser combinator\nfunction t(token) {\n  let post = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : v => v.text;\n  return function (_ref7) {\n    let {\n      index = 0,\n      input\n    } = _ref7;\n    const result = input[index];\n    if (result !== undefined && (token.type === undefined || token.type === result.type) && (token.text === undefined || token.text.toUpperCase() === result.text.toUpperCase())) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input\n      };\n    } else {\n      return {\n        success: false,\n        ast: null,\n        index,\n        input\n      };\n    }\n  };\n}\n\n// Empty parser constant\nconst e = function (_ref8) {\n  let {\n    index = 0,\n    input\n  } = _ref8;\n  return {\n    success: true,\n    ast: null,\n    index,\n    input\n  };\n};\n\n// Finish parser constant\nconst f = function (_ref9) {\n  let {\n    index = 0,\n    input\n  } = _ref9;\n  return {\n    success: index === input.length,\n    ast: null,\n    index,\n    input\n  };\n};\nmodule.exports = {\n  s,\n  a,\n  m,\n  o,\n  l,\n  n,\n  t,\n  e,\n  f\n};","map":{"version":3,"names":["s","sequence","post","arguments","length","undefined","v","_ref","index","input","position","ast","parser","result","success","push","a","alternative","_ref2","m","many","_ref3","o","optional","_ref4","l","lookahead","_ref5","do","resultNext","next","n","negative","_ref6","resultNot","not","t","token","text","_ref7","type","toUpperCase","e","_ref8","f","_ref9","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/dialects/sqlite3/schema/internal/parser-combinator.js"],"sourcesContent":["// Sequence parser combinator\nfunction s(sequence, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let position = index;\n    const ast = [];\n\n    for (const parser of sequence) {\n      const result = parser({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      } else {\n        return result;\n      }\n    }\n\n    return { success: true, ast: post(ast), index: position, input };\n  };\n}\n\n// Alternative parser combinator\nfunction a(alternative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    for (const parser of alternative) {\n      const result = parser({ index, input });\n\n      if (result.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Many parser combinator\nfunction m(many, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    let result = {};\n    let position = index;\n    const ast = [];\n\n    do {\n      result = many({ index: position, input });\n\n      if (result.success) {\n        position = result.index;\n        ast.push(result.ast);\n      }\n    } while (result.success);\n\n    if (ast.length > 0) {\n      return { success: true, ast: post(ast), index: position, input };\n    } else {\n      return { success: false, ast: null, index: position, input };\n    }\n  };\n}\n\n// Optional parser combinator\nfunction o(optional, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = optional({ index, input });\n\n    if (result.success) {\n      return {\n        success: true,\n        ast: post(result.ast),\n        index: result.index,\n        input,\n      };\n    } else {\n      return { success: true, ast: post(null), index, input };\n    }\n  };\n}\n\n// Lookahead parser combinator\nfunction l(lookahead, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = lookahead.do({ index, input });\n\n    if (result.success) {\n      const resultNext = lookahead.next({ index: result.index, input });\n\n      if (resultNext.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Negative parser combinator\nfunction n(negative, post = (v) => v) {\n  return function ({ index = 0, input }) {\n    const result = negative.do({ index, input });\n\n    if (result.success) {\n      const resultNot = negative.not({ index, input });\n\n      if (!resultNot.success) {\n        return {\n          success: true,\n          ast: post(result.ast),\n          index: result.index,\n          input,\n        };\n      }\n    }\n\n    return { success: false, ast: null, index, input };\n  };\n}\n\n// Token parser combinator\nfunction t(token, post = (v) => v.text) {\n  return function ({ index = 0, input }) {\n    const result = input[index];\n\n    if (\n      result !== undefined &&\n      (token.type === undefined || token.type === result.type) &&\n      (token.text === undefined ||\n        token.text.toUpperCase() === result.text.toUpperCase())\n    ) {\n      return {\n        success: true,\n        ast: post(result),\n        index: index + 1,\n        input,\n      };\n    } else {\n      return { success: false, ast: null, index, input };\n    }\n  };\n}\n\n// Empty parser constant\nconst e = function ({ index = 0, input }) {\n  return { success: true, ast: null, index, input };\n};\n\n// Finish parser constant\nconst f = function ({ index = 0, input }) {\n  return { success: index === input.length, ast: null, index, input };\n};\n\nmodule.exports = { s, a, m, o, l, n, t, e, f };\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}