{"ast":null,"code":"const {\n  KnexTimeoutError\n} = require('../util/timeout');\nconst {\n  timeout\n} = require('../util/timeout');\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback\n} = require('./internal/ensure-connection-callback');\nlet Transform;\n\n// The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = [];\n\n    // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n    this.connection = undefined;\n  }\n\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  async run() {\n    const runner = this;\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback);\n\n      // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n      runner.builder.emit('end');\n      return res;\n\n      // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n      throw err;\n    }\n  }\n\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler = typeof optionsOrHandler === 'function' && arguments.length === 1;\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;\n\n    // Determines whether we emit an error or throw here.\n    const hasHandler = typeof handler === 'function';\n\n    // Lazy-load the \"Transform\" dependency.\n    Transform = Transform || require('stream').Transform;\n    const queryContext = this.builder.queryContext();\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      }\n    });\n    stream.on('close', () => {\n      this.client.releaseConnection(this.connection);\n    });\n    const connectionAcquirePromise = this.ensureConnection(ensureConnectionStreamCallback, {\n      options,\n      hasHandler,\n      stream\n    })\n    // Emit errors on the stream if the error occurred before a connection\n    // could be acquired.\n    // If the connection was acquired, assume the error occurred in the client\n    // code and has already been emitted on the stream. Don't emit it twice.\n    .catch(err => {\n      if (!this.connection) {\n        stream.emit('error', err);\n      }\n    });\n\n    // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n    return stream;\n  }\n\n  // Allow you to pipe the stream to a writable stream.\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  }\n\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  async query(obj) {\n    const {\n      __knexUid,\n      __knexTxId\n    } = this.connection;\n    this.builder.emit('query', Object.assign({\n      __knexUid,\n      __knexTxId\n    }, obj));\n    const runner = this;\n    const queryContext = this.builder.queryContext();\n    // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n    let queryPromise = this.client.query(this.connection, obj);\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    }\n\n    // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n    return queryPromise.then(resp => this.client.processResponse(resp, runner)).then(processedResponse => {\n      const postProcessedResponse = this.client.postProcessResponse(processedResponse, queryContext);\n      this.builder.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      this.client.emit('query-response', postProcessedResponse, Object.assign({\n        __knexUid,\n        __knexTxId\n      }, obj), this.builder);\n      return postProcessedResponse;\n    }).catch(error => {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      const {\n        timeout,\n        sql,\n        bindings\n      } = obj;\n      let cancelQuery;\n      if (obj.cancelOnTimeout) {\n        cancelQuery = this.client.cancelQuery(this.connection);\n      } else {\n        // If we don't cancel the query, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error;\n        cancelQuery = Promise.resolve();\n      }\n      return cancelQuery.catch(cancelError => {\n        // If the cancellation failed, we need to mark the connection as disposed so that\n        // it gets destroyed by the pool and is never used again. If we don't do this and\n        // return the connection to the pool, it will be useless until the current operation\n        // that timed out, finally finishes.\n        this.connection.__knex__disposed = error;\n\n        // cancellation failed\n        throw Object.assign(cancelError, {\n          message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n          sql,\n          bindings,\n          timeout\n        });\n      }).then(() => {\n        // cancellation succeeded, rethrow timeout error\n        throw Object.assign(error, {\n          message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n          sql,\n          bindings,\n          timeout\n        });\n      });\n    }).catch(error => {\n      this.builder.emit('query-error', error, Object.assign({\n        __knexUid,\n        __knexTxId,\n        queryContext\n      }, obj));\n      throw error;\n    });\n  }\n\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n      const statements = await query.statementsProducer(undefined, this.connection);\n      const sqlQueryObjects = statements.sql.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      const preQueryObjects = statements.pre.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      const postQueryObjects = statements.post.map(statement => ({\n        sql: statement,\n        bindings: query.bindings\n      }));\n      let results = [];\n      await this.queryArray(preQueryObjects);\n      try {\n        await this.client.transaction(async trx => {\n          const transactionRunner = new Runner(trx.client, this.builder);\n          transactionRunner.connection = this.connection;\n          results = await transactionRunner.queryArray(sqlQueryObjects);\n          if (statements.check) {\n            const foreignViolations = await trx.raw(statements.check);\n            if (foreignViolations.length > 0) {\n              throw new Error('FOREIGN KEY constraint failed');\n            }\n          }\n        }, {\n          connection: this.connection\n        });\n      } finally {\n        await this.queryArray(postQueryObjects);\n      }\n      return results;\n    }\n    const results = [];\n    for (const query of queries) {\n      results.push(await this.queryArray([query]));\n    }\n    return results;\n  }\n\n  // Check whether there's a transaction flag, and that it has a connection.\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n    let acquiredConnection;\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n      throw error;\n    }\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n}\nmodule.exports = Runner;","map":{"version":3,"names":["KnexTimeoutError","require","timeout","ensureConnectionCallback","ensureConnectionStreamCallback","Transform","Runner","constructor","client","builder","queries","connection","undefined","run","runner","res","ensureConnection","emit","err","_events","error","stream","optionsOrHandler","handlerOrNil","firstOptionIsHandler","arguments","length","options","handler","hasHandler","queryContext","objectMode","transform","chunk","_","callback","postProcessResponse","on","releaseConnection","connectionAcquirePromise","catch","pipe","writable","query","obj","__knexUid","__knexTxId","Object","assign","queryPromise","then","resp","processResponse","processedResponse","postProcessedResponse","Promise","reject","sql","bindings","cancelQuery","cancelOnTimeout","__knex__disposed","resolve","cancelError","message","queryArray","statementsProducer","statements","sqlQueryObjects","map","statement","preQueryObjects","pre","postQueryObjects","post","results","transaction","trx","transactionRunner","check","foreignViolations","raw","Error","push","cb","cbParams","_connection","acquiredConnection","acquireConnection","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/execution/runner.js"],"sourcesContent":["const { KnexTimeoutError } = require('../util/timeout');\nconst { timeout } = require('../util/timeout');\nconst {\n  ensureConnectionCallback,\n  ensureConnectionStreamCallback,\n} = require('./internal/ensure-connection-callback');\n\nlet Transform;\n\n// The \"Runner\" constructor takes a \"builder\" (query, schema, or raw)\n// and runs through each of the query statements, calling any additional\n// \"output\" method provided alongside the query and bindings.\nclass Runner {\n  constructor(client, builder) {\n    this.client = client;\n    this.builder = builder;\n    this.queries = [];\n\n    // The \"connection\" object is set on the runner when\n    // \"run\" is called.\n    this.connection = undefined;\n  }\n\n  // \"Run\" the target, calling \"toSQL\" on the builder, returning\n  // an object or array of queries to run, each of which are run on\n  // a single connection.\n  async run() {\n    const runner = this;\n    try {\n      const res = await this.ensureConnection(ensureConnectionCallback);\n\n      // Fire a single \"end\" event on the builder when\n      // all queries have successfully completed.\n      runner.builder.emit('end');\n      return res;\n\n      // If there are any \"error\" listeners, we fire an error event\n      // and then re-throw the error to be eventually handled by\n      // the promise chain. Useful if you're wrapping in a custom `Promise`.\n    } catch (err) {\n      if (runner.builder._events && runner.builder._events.error) {\n        runner.builder.emit('error', err);\n      }\n      throw err;\n    }\n  }\n\n  // Stream the result set, by passing through to the dialect's streaming\n  // capabilities. If the options are\n  stream(optionsOrHandler, handlerOrNil) {\n    const firstOptionIsHandler =\n      typeof optionsOrHandler === 'function' && arguments.length === 1;\n\n    const options = firstOptionIsHandler ? {} : optionsOrHandler;\n    const handler = firstOptionIsHandler ? optionsOrHandler : handlerOrNil;\n\n    // Determines whether we emit an error or throw here.\n    const hasHandler = typeof handler === 'function';\n\n    // Lazy-load the \"Transform\" dependency.\n    Transform = Transform || require('stream').Transform;\n\n    const queryContext = this.builder.queryContext();\n\n    const stream = new Transform({\n      objectMode: true,\n      transform: (chunk, _, callback) => {\n        callback(null, this.client.postProcessResponse(chunk, queryContext));\n      },\n    });\n    stream.on('close', () => {\n      this.client.releaseConnection(this.connection);\n    });\n\n    const connectionAcquirePromise = this.ensureConnection(\n      ensureConnectionStreamCallback,\n      {\n        options,\n        hasHandler,\n        stream,\n      }\n    )\n      // Emit errors on the stream if the error occurred before a connection\n      // could be acquired.\n      // If the connection was acquired, assume the error occurred in the client\n      // code and has already been emitted on the stream. Don't emit it twice.\n      .catch((err) => {\n        if (!this.connection) {\n          stream.emit('error', err);\n        }\n      });\n\n    // If a function is passed to handle the stream, send the stream\n    // there and return the promise, otherwise just return the stream\n    // and the promise will take care of itself.\n    if (hasHandler) {\n      handler(stream);\n      return connectionAcquirePromise;\n    }\n    return stream;\n  }\n\n  // Allow you to pipe the stream to a writable stream.\n  pipe(writable, options) {\n    return this.stream(options).pipe(writable);\n  }\n\n  // \"Runs\" a query, returning a promise. All queries specified by the builder are guaranteed\n  // to run in sequence, and on the same connection, especially helpful when schema building\n  // and dealing with foreign key constraints, etc.\n  async query(obj) {\n    const { __knexUid, __knexTxId } = this.connection;\n\n    this.builder.emit('query', Object.assign({ __knexUid, __knexTxId }, obj));\n\n    const runner = this;\n    const queryContext = this.builder.queryContext();\n    // query-error events are emitted before the queryPromise continuations.\n    // pass queryContext into client.query so it can be raised properly.\n    if (obj !== null && typeof obj === 'object') {\n      obj.queryContext = queryContext;\n    }\n    let queryPromise = this.client.query(this.connection, obj);\n\n    if (obj.timeout) {\n      queryPromise = timeout(queryPromise, obj.timeout);\n    }\n\n    // Await the return value of client.processResponse; in the case of sqlite3's\n    // dropColumn()/renameColumn(), it will be a Promise for the transaction\n    // containing the complete rename procedure.\n    return queryPromise\n      .then((resp) => this.client.processResponse(resp, runner))\n      .then((processedResponse) => {\n        const postProcessedResponse = this.client.postProcessResponse(\n          processedResponse,\n          queryContext\n        );\n\n        this.builder.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        this.client.emit(\n          'query-response',\n          postProcessedResponse,\n          Object.assign({ __knexUid, __knexTxId }, obj),\n          this.builder\n        );\n\n        return postProcessedResponse;\n      })\n      .catch((error) => {\n        if (!(error instanceof KnexTimeoutError)) {\n          return Promise.reject(error);\n        }\n        const { timeout, sql, bindings } = obj;\n\n        let cancelQuery;\n        if (obj.cancelOnTimeout) {\n          cancelQuery = this.client.cancelQuery(this.connection);\n        } else {\n          // If we don't cancel the query, we need to mark the connection as disposed so that\n          // it gets destroyed by the pool and is never used again. If we don't do this and\n          // return the connection to the pool, it will be useless until the current operation\n          // that timed out, finally finishes.\n          this.connection.__knex__disposed = error;\n          cancelQuery = Promise.resolve();\n        }\n\n        return cancelQuery\n          .catch((cancelError) => {\n            // If the cancellation failed, we need to mark the connection as disposed so that\n            // it gets destroyed by the pool and is never used again. If we don't do this and\n            // return the connection to the pool, it will be useless until the current operation\n            // that timed out, finally finishes.\n            this.connection.__knex__disposed = error;\n\n            // cancellation failed\n            throw Object.assign(cancelError, {\n              message: `After query timeout of ${timeout}ms exceeded, cancelling of query failed.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          })\n          .then(() => {\n            // cancellation succeeded, rethrow timeout error\n            throw Object.assign(error, {\n              message: `Defined query timeout of ${timeout}ms exceeded when running query.`,\n              sql,\n              bindings,\n              timeout,\n            });\n          });\n      })\n      .catch((error) => {\n        this.builder.emit(\n          'query-error',\n          error,\n          Object.assign({ __knexUid, __knexTxId, queryContext }, obj)\n        );\n        throw error;\n      });\n  }\n\n  // In the case of the \"schema builder\" we call `queryArray`, which runs each\n  // of the queries in sequence.\n  async queryArray(queries) {\n    if (queries.length === 1) {\n      const query = queries[0];\n\n      if (!query.statementsProducer) {\n        return this.query(query);\n      }\n\n      const statements = await query.statementsProducer(\n        undefined,\n        this.connection\n      );\n\n      const sqlQueryObjects = statements.sql.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n      const preQueryObjects = statements.pre.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n      const postQueryObjects = statements.post.map((statement) => ({\n        sql: statement,\n        bindings: query.bindings,\n      }));\n\n      let results = [];\n\n      await this.queryArray(preQueryObjects);\n\n      try {\n        await this.client.transaction(\n          async (trx) => {\n            const transactionRunner = new Runner(trx.client, this.builder);\n            transactionRunner.connection = this.connection;\n\n            results = await transactionRunner.queryArray(sqlQueryObjects);\n\n            if (statements.check) {\n              const foreignViolations = await trx.raw(statements.check);\n\n              if (foreignViolations.length > 0) {\n                throw new Error('FOREIGN KEY constraint failed');\n              }\n            }\n          },\n          { connection: this.connection }\n        );\n      } finally {\n        await this.queryArray(postQueryObjects);\n      }\n\n      return results;\n    }\n\n    const results = [];\n    for (const query of queries) {\n      results.push(await this.queryArray([query]));\n    }\n    return results;\n  }\n\n  // Check whether there's a transaction flag, and that it has a connection.\n  async ensureConnection(cb, cbParams) {\n    // Use override from a builder if passed\n    if (this.builder._connection) {\n      this.connection = this.builder._connection;\n    }\n\n    if (this.connection) {\n      return cb(this, cbParams);\n    }\n\n    let acquiredConnection;\n    try {\n      acquiredConnection = await this.client.acquireConnection();\n    } catch (error) {\n      if (!(error instanceof KnexTimeoutError)) {\n        return Promise.reject(error);\n      }\n      if (this.builder) {\n        error.sql = this.builder.sql;\n        error.bindings = this.builder.bindings;\n      }\n      throw error;\n    }\n    try {\n      this.connection = acquiredConnection;\n      return await cb(this, cbParams);\n    } finally {\n      await this.client.releaseConnection(acquiredConnection);\n    }\n  }\n}\n\nmodule.exports = Runner;\n"],"mappings":"AAAA,MAAM;EAAEA;AAAiB,CAAC,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AACvD,MAAM;EAAEC;AAAQ,CAAC,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAM;EACJE,wBAAwB;EACxBC;AACF,CAAC,GAAGH,OAAO,CAAC,uCAAuC,CAAC;AAEpD,IAAII,SAAS;;AAEb;AACA;AACA;AACA,MAAMC,MAAM,CAAC;EACXC,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC3B,IAAI,CAACD,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,OAAO,GAAG,EAAE;;IAEjB;IACA;IACA,IAAI,CAACC,UAAU,GAAGC,SAAS;EAC7B;;EAEA;EACA;EACA;EACA,MAAMC,GAAGA,CAAA,EAAG;IACV,MAAMC,MAAM,GAAG,IAAI;IACnB,IAAI;MACF,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACC,gBAAgB,CAACb,wBAAwB,CAAC;;MAEjE;MACA;MACAW,MAAM,CAACL,OAAO,CAACQ,IAAI,CAAC,KAAK,CAAC;MAC1B,OAAOF,GAAG;;MAEV;MACA;MACA;IACF,CAAC,CAAC,OAAOG,GAAG,EAAE;MACZ,IAAIJ,MAAM,CAACL,OAAO,CAACU,OAAO,IAAIL,MAAM,CAACL,OAAO,CAACU,OAAO,CAACC,KAAK,EAAE;QAC1DN,MAAM,CAACL,OAAO,CAACQ,IAAI,CAAC,OAAO,EAAEC,GAAG,CAAC;MACnC;MACA,MAAMA,GAAG;IACX;EACF;;EAEA;EACA;EACAG,MAAMA,CAACC,gBAAgB,EAAEC,YAAY,EAAE;IACrC,MAAMC,oBAAoB,GACxB,OAAOF,gBAAgB,KAAK,UAAU,IAAIG,SAAS,CAACC,MAAM,KAAK,CAAC;IAElE,MAAMC,OAAO,GAAGH,oBAAoB,GAAG,CAAC,CAAC,GAAGF,gBAAgB;IAC5D,MAAMM,OAAO,GAAGJ,oBAAoB,GAAGF,gBAAgB,GAAGC,YAAY;;IAEtE;IACA,MAAMM,UAAU,GAAG,OAAOD,OAAO,KAAK,UAAU;;IAEhD;IACAvB,SAAS,GAAGA,SAAS,IAAIJ,OAAO,CAAC,QAAQ,CAAC,CAACI,SAAS;IAEpD,MAAMyB,YAAY,GAAG,IAAI,CAACrB,OAAO,CAACqB,YAAY,CAAC,CAAC;IAEhD,MAAMT,MAAM,GAAG,IAAIhB,SAAS,CAAC;MAC3B0B,UAAU,EAAE,IAAI;MAChBC,SAAS,EAAEA,CAACC,KAAK,EAAEC,CAAC,EAAEC,QAAQ,KAAK;QACjCA,QAAQ,CAAC,IAAI,EAAE,IAAI,CAAC3B,MAAM,CAAC4B,mBAAmB,CAACH,KAAK,EAAEH,YAAY,CAAC,CAAC;MACtE;IACF,CAAC,CAAC;IACFT,MAAM,CAACgB,EAAE,CAAC,OAAO,EAAE,MAAM;MACvB,IAAI,CAAC7B,MAAM,CAAC8B,iBAAiB,CAAC,IAAI,CAAC3B,UAAU,CAAC;IAChD,CAAC,CAAC;IAEF,MAAM4B,wBAAwB,GAAG,IAAI,CAACvB,gBAAgB,CACpDZ,8BAA8B,EAC9B;MACEuB,OAAO;MACPE,UAAU;MACVR;IACF,CACF;IACE;IACA;IACA;IACA;IAAA,CACCmB,KAAK,CAAEtB,GAAG,IAAK;MACd,IAAI,CAAC,IAAI,CAACP,UAAU,EAAE;QACpBU,MAAM,CAACJ,IAAI,CAAC,OAAO,EAAEC,GAAG,CAAC;MAC3B;IACF,CAAC,CAAC;;IAEJ;IACA;IACA;IACA,IAAIW,UAAU,EAAE;MACdD,OAAO,CAACP,MAAM,CAAC;MACf,OAAOkB,wBAAwB;IACjC;IACA,OAAOlB,MAAM;EACf;;EAEA;EACAoB,IAAIA,CAACC,QAAQ,EAAEf,OAAO,EAAE;IACtB,OAAO,IAAI,CAACN,MAAM,CAACM,OAAO,CAAC,CAACc,IAAI,CAACC,QAAQ,CAAC;EAC5C;;EAEA;EACA;EACA;EACA,MAAMC,KAAKA,CAACC,GAAG,EAAE;IACf,MAAM;MAAEC,SAAS;MAAEC;IAAW,CAAC,GAAG,IAAI,CAACnC,UAAU;IAEjD,IAAI,CAACF,OAAO,CAACQ,IAAI,CAAC,OAAO,EAAE8B,MAAM,CAACC,MAAM,CAAC;MAAEH,SAAS;MAAEC;IAAW,CAAC,EAAEF,GAAG,CAAC,CAAC;IAEzE,MAAM9B,MAAM,GAAG,IAAI;IACnB,MAAMgB,YAAY,GAAG,IAAI,CAACrB,OAAO,CAACqB,YAAY,CAAC,CAAC;IAChD;IACA;IACA,IAAIc,GAAG,KAAK,IAAI,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;MAC3CA,GAAG,CAACd,YAAY,GAAGA,YAAY;IACjC;IACA,IAAImB,YAAY,GAAG,IAAI,CAACzC,MAAM,CAACmC,KAAK,CAAC,IAAI,CAAChC,UAAU,EAAEiC,GAAG,CAAC;IAE1D,IAAIA,GAAG,CAAC1C,OAAO,EAAE;MACf+C,YAAY,GAAG/C,OAAO,CAAC+C,YAAY,EAAEL,GAAG,CAAC1C,OAAO,CAAC;IACnD;;IAEA;IACA;IACA;IACA,OAAO+C,YAAY,CAChBC,IAAI,CAAEC,IAAI,IAAK,IAAI,CAAC3C,MAAM,CAAC4C,eAAe,CAACD,IAAI,EAAErC,MAAM,CAAC,CAAC,CACzDoC,IAAI,CAAEG,iBAAiB,IAAK;MAC3B,MAAMC,qBAAqB,GAAG,IAAI,CAAC9C,MAAM,CAAC4B,mBAAmB,CAC3DiB,iBAAiB,EACjBvB,YACF,CAAC;MAED,IAAI,CAACrB,OAAO,CAACQ,IAAI,CACf,gBAAgB,EAChBqC,qBAAqB,EACrBP,MAAM,CAACC,MAAM,CAAC;QAAEH,SAAS;QAAEC;MAAW,CAAC,EAAEF,GAAG,CAAC,EAC7C,IAAI,CAACnC,OACP,CAAC;MAED,IAAI,CAACD,MAAM,CAACS,IAAI,CACd,gBAAgB,EAChBqC,qBAAqB,EACrBP,MAAM,CAACC,MAAM,CAAC;QAAEH,SAAS;QAAEC;MAAW,CAAC,EAAEF,GAAG,CAAC,EAC7C,IAAI,CAACnC,OACP,CAAC;MAED,OAAO6C,qBAAqB;IAC9B,CAAC,CAAC,CACDd,KAAK,CAAEpB,KAAK,IAAK;MAChB,IAAI,EAAEA,KAAK,YAAYpB,gBAAgB,CAAC,EAAE;QACxC,OAAOuD,OAAO,CAACC,MAAM,CAACpC,KAAK,CAAC;MAC9B;MACA,MAAM;QAAElB,OAAO;QAAEuD,GAAG;QAAEC;MAAS,CAAC,GAAGd,GAAG;MAEtC,IAAIe,WAAW;MACf,IAAIf,GAAG,CAACgB,eAAe,EAAE;QACvBD,WAAW,GAAG,IAAI,CAACnD,MAAM,CAACmD,WAAW,CAAC,IAAI,CAAChD,UAAU,CAAC;MACxD,CAAC,MAAM;QACL;QACA;QACA;QACA;QACA,IAAI,CAACA,UAAU,CAACkD,gBAAgB,GAAGzC,KAAK;QACxCuC,WAAW,GAAGJ,OAAO,CAACO,OAAO,CAAC,CAAC;MACjC;MAEA,OAAOH,WAAW,CACfnB,KAAK,CAAEuB,WAAW,IAAK;QACtB;QACA;QACA;QACA;QACA,IAAI,CAACpD,UAAU,CAACkD,gBAAgB,GAAGzC,KAAK;;QAExC;QACA,MAAM2B,MAAM,CAACC,MAAM,CAACe,WAAW,EAAE;UAC/BC,OAAO,EAAG,0BAAyB9D,OAAQ,0CAAyC;UACpFuD,GAAG;UACHC,QAAQ;UACRxD;QACF,CAAC,CAAC;MACJ,CAAC,CAAC,CACDgD,IAAI,CAAC,MAAM;QACV;QACA,MAAMH,MAAM,CAACC,MAAM,CAAC5B,KAAK,EAAE;UACzB4C,OAAO,EAAG,4BAA2B9D,OAAQ,iCAAgC;UAC7EuD,GAAG;UACHC,QAAQ;UACRxD;QACF,CAAC,CAAC;MACJ,CAAC,CAAC;IACN,CAAC,CAAC,CACDsC,KAAK,CAAEpB,KAAK,IAAK;MAChB,IAAI,CAACX,OAAO,CAACQ,IAAI,CACf,aAAa,EACbG,KAAK,EACL2B,MAAM,CAACC,MAAM,CAAC;QAAEH,SAAS;QAAEC,UAAU;QAAEhB;MAAa,CAAC,EAAEc,GAAG,CAC5D,CAAC;MACD,MAAMxB,KAAK;IACb,CAAC,CAAC;EACN;;EAEA;EACA;EACA,MAAM6C,UAAUA,CAACvD,OAAO,EAAE;IACxB,IAAIA,OAAO,CAACgB,MAAM,KAAK,CAAC,EAAE;MACxB,MAAMiB,KAAK,GAAGjC,OAAO,CAAC,CAAC,CAAC;MAExB,IAAI,CAACiC,KAAK,CAACuB,kBAAkB,EAAE;QAC7B,OAAO,IAAI,CAACvB,KAAK,CAACA,KAAK,CAAC;MAC1B;MAEA,MAAMwB,UAAU,GAAG,MAAMxB,KAAK,CAACuB,kBAAkB,CAC/CtD,SAAS,EACT,IAAI,CAACD,UACP,CAAC;MAED,MAAMyD,eAAe,GAAGD,UAAU,CAACV,GAAG,CAACY,GAAG,CAAEC,SAAS,KAAM;QACzDb,GAAG,EAAEa,SAAS;QACdZ,QAAQ,EAAEf,KAAK,CAACe;MAClB,CAAC,CAAC,CAAC;MACH,MAAMa,eAAe,GAAGJ,UAAU,CAACK,GAAG,CAACH,GAAG,CAAEC,SAAS,KAAM;QACzDb,GAAG,EAAEa,SAAS;QACdZ,QAAQ,EAAEf,KAAK,CAACe;MAClB,CAAC,CAAC,CAAC;MACH,MAAMe,gBAAgB,GAAGN,UAAU,CAACO,IAAI,CAACL,GAAG,CAAEC,SAAS,KAAM;QAC3Db,GAAG,EAAEa,SAAS;QACdZ,QAAQ,EAAEf,KAAK,CAACe;MAClB,CAAC,CAAC,CAAC;MAEH,IAAIiB,OAAO,GAAG,EAAE;MAEhB,MAAM,IAAI,CAACV,UAAU,CAACM,eAAe,CAAC;MAEtC,IAAI;QACF,MAAM,IAAI,CAAC/D,MAAM,CAACoE,WAAW,CAC3B,MAAOC,GAAG,IAAK;UACb,MAAMC,iBAAiB,GAAG,IAAIxE,MAAM,CAACuE,GAAG,CAACrE,MAAM,EAAE,IAAI,CAACC,OAAO,CAAC;UAC9DqE,iBAAiB,CAACnE,UAAU,GAAG,IAAI,CAACA,UAAU;UAE9CgE,OAAO,GAAG,MAAMG,iBAAiB,CAACb,UAAU,CAACG,eAAe,CAAC;UAE7D,IAAID,UAAU,CAACY,KAAK,EAAE;YACpB,MAAMC,iBAAiB,GAAG,MAAMH,GAAG,CAACI,GAAG,CAACd,UAAU,CAACY,KAAK,CAAC;YAEzD,IAAIC,iBAAiB,CAACtD,MAAM,GAAG,CAAC,EAAE;cAChC,MAAM,IAAIwD,KAAK,CAAC,+BAA+B,CAAC;YAClD;UACF;QACF,CAAC,EACD;UAAEvE,UAAU,EAAE,IAAI,CAACA;QAAW,CAChC,CAAC;MACH,CAAC,SAAS;QACR,MAAM,IAAI,CAACsD,UAAU,CAACQ,gBAAgB,CAAC;MACzC;MAEA,OAAOE,OAAO;IAChB;IAEA,MAAMA,OAAO,GAAG,EAAE;IAClB,KAAK,MAAMhC,KAAK,IAAIjC,OAAO,EAAE;MAC3BiE,OAAO,CAACQ,IAAI,CAAC,MAAM,IAAI,CAAClB,UAAU,CAAC,CAACtB,KAAK,CAAC,CAAC,CAAC;IAC9C;IACA,OAAOgC,OAAO;EAChB;;EAEA;EACA,MAAM3D,gBAAgBA,CAACoE,EAAE,EAAEC,QAAQ,EAAE;IACnC;IACA,IAAI,IAAI,CAAC5E,OAAO,CAAC6E,WAAW,EAAE;MAC5B,IAAI,CAAC3E,UAAU,GAAG,IAAI,CAACF,OAAO,CAAC6E,WAAW;IAC5C;IAEA,IAAI,IAAI,CAAC3E,UAAU,EAAE;MACnB,OAAOyE,EAAE,CAAC,IAAI,EAAEC,QAAQ,CAAC;IAC3B;IAEA,IAAIE,kBAAkB;IACtB,IAAI;MACFA,kBAAkB,GAAG,MAAM,IAAI,CAAC/E,MAAM,CAACgF,iBAAiB,CAAC,CAAC;IAC5D,CAAC,CAAC,OAAOpE,KAAK,EAAE;MACd,IAAI,EAAEA,KAAK,YAAYpB,gBAAgB,CAAC,EAAE;QACxC,OAAOuD,OAAO,CAACC,MAAM,CAACpC,KAAK,CAAC;MAC9B;MACA,IAAI,IAAI,CAACX,OAAO,EAAE;QAChBW,KAAK,CAACqC,GAAG,GAAG,IAAI,CAAChD,OAAO,CAACgD,GAAG;QAC5BrC,KAAK,CAACsC,QAAQ,GAAG,IAAI,CAACjD,OAAO,CAACiD,QAAQ;MACxC;MACA,MAAMtC,KAAK;IACb;IACA,IAAI;MACF,IAAI,CAACT,UAAU,GAAG4E,kBAAkB;MACpC,OAAO,MAAMH,EAAE,CAAC,IAAI,EAAEC,QAAQ,CAAC;IACjC,CAAC,SAAS;MACR,MAAM,IAAI,CAAC7E,MAAM,CAAC8B,iBAAiB,CAACiD,kBAAkB,CAAC;IACzD;EACF;AACF;AAEAE,MAAM,CAACC,OAAO,GAAGpF,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}