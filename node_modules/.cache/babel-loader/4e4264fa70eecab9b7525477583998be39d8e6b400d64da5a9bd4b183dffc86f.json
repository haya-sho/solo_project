{"ast":null,"code":"// Builder\n// -------\nconst assert = require('assert');\nconst {\n  EventEmitter\n} = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\nconst {\n  addQueryContext,\n  normalizeArr\n} = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction\n} = require('../util/is');\nconst {\n  lockMode,\n  waitMode\n} = require('./constants');\nconst {\n  augmentWithBuilderInterface\n} = require('../builder-interface-augmenter');\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set(['with', 'select', 'columns', 'hintComments', 'where', 'union', 'join', 'group', 'order', 'having', 'limit', 'offset', 'counter', 'counters']);\nconst LOCK_MODES = new Set([lockMode.forShare, lockMode.forUpdate, lockMode.forNoKeyUpdate, lockMode.forKeyShare]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n    return cloned;\n  }\n  timeout(ms) {\n    let {\n      cancel\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return typeof statement === 'function' || statement instanceof Builder || statement && statement.isRawInstance;\n  }\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList = Array.isArray(columnList) && columnList.length > 0 && columnList.every(it => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(`${method}() second argument must be a statement or non-empty column name list.`);\n    }\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(`${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`);\n  }\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'with');\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] = typeof nothingOrStatement === 'undefined' ? [statementOrColumnList, undefined] : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(alias, statementOrColumnList, nothingOrStatement, 'withRecursive');\n    return this.withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some(hint => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some(hint => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some(hint => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct() {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n      distinct: true\n    });\n    return this;\n  }\n  distinctOn() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first) {\n    let join;\n    const schema = table instanceof Builder || typeof table === 'function' ? undefined : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n  using(tables) {\n    throw new Error(\"'using' function is only available in PostgreSQL dialect with Delete statements.\");\n  }\n\n  // JOIN blocks:\n  innerJoin() {\n    return this._joinType('inner').join(...arguments);\n  }\n  leftJoin() {\n    return this._joinType('left').join(...arguments);\n  }\n  leftOuterJoin() {\n    return this._joinType('left outer').join(...arguments);\n  }\n  rightJoin() {\n    return this._joinType('right').join(...arguments);\n  }\n  rightOuterJoin() {\n    return this._joinType('right outer').join(...arguments);\n  }\n  outerJoin() {\n    return this._joinType('outer').join(...arguments);\n  }\n  fullOuterJoin() {\n    return this._joinType('full outer').join(...arguments);\n  }\n  crossJoin() {\n    return this._joinType('cross').join(...arguments);\n  }\n  joinRaw() {\n    return this._joinType('raw').join(...arguments);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance) return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1) return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(column, value);\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n  whereColumn() {\n    this._asColumnFlag = true;\n    this.where(...arguments);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.where(column, ...args);\n  }\n  orWhereColumn(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn('whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.');\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n  whereNotColumn() {\n    return this._not(true).whereColumn(...arguments);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot() {\n    return this._bool('or').whereNot(...arguments);\n  }\n  orWhereNotColumn() {\n    return this._bool('or').whereNotColumn(...arguments);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to whereBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the whereBetween clause');\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments)\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction) {\n    let nulls = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls']\n        });\n      } else if (isString(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw\n    });\n    return this;\n  }\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || args.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union() {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll() {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n    return this._union('union all', args);\n  }\n\n  // Adds an intersect statement to the query\n  intersect(callbacks, wrap) {\n    if (arguments.length === 1 || arguments.length === 2 && isBoolean(wrap)) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: 'intersect',\n          value: callbacks[i],\n          wrap: wrap || false\n        });\n      }\n    } else {\n      callbacks = toArray(arguments).slice(0, arguments.length - 1);\n      wrap = arguments[arguments.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this.intersect(callbacks, wrap);\n    }\n    return this;\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHaving(column) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    for (var _len8 = arguments.length, args = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n      args[_key8 - 1] = arguments[_key8];\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n  havingBetween(column, values) {\n    assert(Array.isArray(values), 'The second argument to havingBetween must be an array.');\n    assert(values.length === 2, 'You must specify 2 values for the havingBetween clause');\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values)) return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool()\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not()\n    });\n    return this;\n  }\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct() {\n    for (var _len9 = arguments.length, columns = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      columns[_key9] = arguments[_key9];\n    }\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n    return this._aggregate('count', columns, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, {\n      ...options,\n      distinct: true\n    });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column) {\n    let amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n      return this;\n    }\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first() {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n    this.select(normalizeArr(...arguments));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement)) throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate() {\n    this._single.lock = lockMode.forUpdate;\n    for (var _len10 = arguments.length, tables = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      tables[_key10] = arguments[_key10];\n    }\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare() {\n    this._single.lock = lockMode.forShare;\n    for (var _len11 = arguments.length, tables = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {\n      tables[_key11] = arguments[_key11];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate() {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    for (var _len12 = arguments.length, tables = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n      tables[_key12] = arguments[_key12];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare() {\n    this._single.lock = lockMode.forKeyShare;\n    for (var _len13 = arguments.length, tables = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n      tables[_key13] = arguments[_key13];\n    }\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.skipLocked() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error('.noWait() can only be used after a call to .forShare() or .forUpdate()!');\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n  upsert(values, returning, options) {\n    throw new Error(`Upsert is not yet supported for dialect ${this.client.dialect}`);\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params\n    });\n    return this;\n  }\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (arguments.length === 2 && Array.isArray(arguments[0]) && isBoolean(arguments[1])) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias\n    });\n  }\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const {\n      schema\n    } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n    assert(typeof second === 'function' || second.isRawInstance || Array.isArray(second) || typeof second === 'string' || typeof second === 'object', `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`);\n    if (third) {\n      assert(Array.isArray(third) || typeof third === 'string' || typeof third === 'object', 'The third argument to an analytic function must be either a string, an array of string or object or an object.');\n    }\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n  rank() {\n    return this._analyticMethod('rank')._analytic(...arguments);\n  }\n  denseRank() {\n    return this._analyticMethod('dense_rank')._analytic(...arguments);\n  }\n  rowNumber() {\n    return this._analyticMethod('row_number')._analytic(...arguments);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n    this._method = 'update';\n    this._single.counter = this._single.counter || {};\n    this._single.counter[column] = amount;\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, {\n        grouping\n      });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(`Can't extend QueryBuilder with existing method ('${methodName}').`);\n  }\n  assign(Builder.prototype, {\n    [methodName]: fn\n  });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = {\n      updates\n    };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error('Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()');\n  }\n}\nmodule.exports = Builder;","map":{"version":3,"names":["assert","require","EventEmitter","assign","clone","each","isEmpty","isPlainObject","last","reject","tail","toArray","addQueryContext","normalizeArr","JoinClause","Analytic","saveAsyncStack","isBoolean","isNumber","isObject","isString","isFunction","lockMode","waitMode","augmentWithBuilderInterface","SELECT_COMMANDS","Set","CLEARABLE_STATEMENTS","LOCK_MODES","forShare","forUpdate","forNoKeyUpdate","forKeyShare","Builder","constructor","client","and","_single","_statements","_method","config","_debug","debug","_joinFlag","_boolFlag","_notFlag","_asColumnFlag","toString","toQuery","toSQL","method","tz","queryCompiler","cloned","_options","undefined","_queryContext","_connection","timeout","ms","cancel","arguments","length","_timeout","assertCanCancelQuery","_cancelOnTimeout","isValidStatementArg","statement","isRawInstance","_validateWithArgs","alias","statementOrColumnList","nothingOrStatement","query","columnList","Error","isNonEmptyNameList","Array","isArray","every","it","with","withWrapped","withMaterialized","withNotMaterialized","materialized","grouping","type","value","push","withRecursive","withRecursiveWrapped","recursive","columns","column","as","hintComment","hints","some","hint","includes","withSchema","schemaName","schema","table","tableName","options","only","distinct","distinctOn","_len","args","_key","join","first","joinType","_joinType","call","raw","_len2","_key2","on","using","tables","innerJoin","leftJoin","leftOuterJoin","rightJoin","rightOuterJoin","outerJoin","fullOuterJoin","crossJoin","joinRaw","or","_bool","not","_not","where","operator","argsLength","whereWrapped","_objectWhere","whereRaw","whereNull","checkOperator","toLowerCase","trim","whereIn","whereBetween","bool","asColumn","whereColumn","orWhere","obj","key","andWhere","_len3","_key3","orWhereColumn","andWhereColumn","_len4","_key4","whereNot","_len5","_key5","logger","warn","whereNotColumn","orWhereNot","orWhereNotColumn","boolVal","notVal","sql","bindings","orWhereRaw","callback","whereExists","orWhereExists","whereNotExists","orWhereNotExists","values","orWhereIn","whereNotIn","orWhereNotIn","orWhereNull","whereNotNull","orWhereNotNull","whereNotBetween","orWhereBetween","orWhereNotBetween","_whereLike","whereLike","orWhereLike","whereILike","orWhereILike","groupBy","item","groupByRaw","apply","orderBy","direction","nulls","_orderByArray","columnDefs","i","columnInfo","orderByRaw","_union","clause","callbacks","wrap","l","slice","union","_len6","_key6","unionAll","_len7","_key7","intersect","having","havingRaw","havingWrapped","orHaving","andHaving","_len8","_key8","havingNull","orHavingNull","havingNotNull","orHavingNotNull","havingExists","orHavingExists","havingNotExists","orHavingNotExists","havingBetween","orHavingBetween","havingNotBetween","orHavingNotBetween","havingIn","orHavingIn","havingNotIn","orHavingNotIn","orHavingRaw","_setSkipBinding","attribute","skipBinding","offset","val","parseInt","isNaN","limit","count","_aggregate","min","max","sum","avg","countDistinct","_len9","_key9","splice","sumDistinct","avgDistinct","increment","amount","_counter","decrement","clearCounters","counter","select","connection","processPassedConnection","pluck","clearSelect","_clearGrouping","clearWhere","clearGroup","clearOrder","clearHaving","clear","has","startsWith","insert","returning","update","ret","JSON","stringify","keys","Object","onConflict","OnConflictBuilder","delete","truncate","lock","_len10","_key10","lockTables","_len11","_key11","_len12","_key12","_len13","_key13","skipLocked","_isSelectQuery","_hasLockMode","noWait","fromJS","fromRaw","from","modify","concat","upsert","dialect","_json","nameFunction","params","jsonExtract","path","singleValue","jsonSet","jsonInsert","jsonRemove","_isJsonObject","jsonValue","_whereJsonWrappedValue","whereJsonClause","jsonPath","whereJsonObject","orWhereJsonObject","whereNotJsonObject","orWhereNotJsonObject","whereJsonPath","orWhereJsonPath","whereJsonSupersetOf","whereJsonNotSupersetOf","orWhereJsonSupersetOf","orWhereJsonNotSupersetOf","whereJsonSubsetOf","whereJsonNotSubsetOf","orWhereJsonSubsetOf","orWhereJsonNotSubsetOf","whereJsonHasNone","whereJsonHasAll","_analytic","second","third","analytic","_analyticMethod","order","partitions","rank","denseRank","rowNumber","parseFloat","_analyticFlag","aggregateDistinct","prototype","andWhereNot","andWhereNotColumn","andWhereRaw","andWhereBetween","andWhereNotBetween","andWhereJsonObject","andWhereNotJsonObject","andWhereJsonPath","andWhereLike","andWhereILike","andHavingIn","andHavingNotIn","andHavingNull","andHavingNotNull","andHavingExists","andHavingNotExists","andHavingBetween","andHavingNotBetween","into","del","extend","methodName","fn","hasOwnProperty","builder","_columns","ignore","merge","updates","then","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/query/querybuilder.js"],"sourcesContent":["// Builder\n// -------\nconst assert = require('assert');\nconst { EventEmitter } = require('events');\nconst assign = require('lodash/assign');\nconst clone = require('lodash/clone');\nconst each = require('lodash/each');\nconst isEmpty = require('lodash/isEmpty');\nconst isPlainObject = require('lodash/isPlainObject');\nconst last = require('lodash/last');\nconst reject = require('lodash/reject');\nconst tail = require('lodash/tail');\nconst toArray = require('lodash/toArray');\n\nconst { addQueryContext, normalizeArr } = require('../util/helpers');\nconst JoinClause = require('./joinclause');\nconst Analytic = require('./analytic');\nconst saveAsyncStack = require('../util/save-async-stack');\nconst {\n  isBoolean,\n  isNumber,\n  isObject,\n  isString,\n  isFunction,\n} = require('../util/is');\n\nconst { lockMode, waitMode } = require('./constants');\nconst {\n  augmentWithBuilderInterface,\n} = require('../builder-interface-augmenter');\n\nconst SELECT_COMMANDS = new Set(['pluck', 'first', 'select']);\nconst CLEARABLE_STATEMENTS = new Set([\n  'with',\n  'select',\n  'columns',\n  'hintComments',\n  'where',\n  'union',\n  'join',\n  'group',\n  'order',\n  'having',\n  'limit',\n  'offset',\n  'counter',\n  'counters',\n]);\nconst LOCK_MODES = new Set([\n  lockMode.forShare,\n  lockMode.forUpdate,\n  lockMode.forNoKeyUpdate,\n  lockMode.forKeyShare,\n]);\n\n// Typically called from `knex.builder`,\n// start a new query building chain.\nclass Builder extends EventEmitter {\n  constructor(client) {\n    super();\n    this.client = client;\n    this.and = this;\n    this._single = {};\n    this._statements = [];\n    this._method = 'select';\n    if (client.config) {\n      saveAsyncStack(this, 5);\n      this._debug = client.config.debug;\n    }\n    // Internal flags used in the builder.\n    this._joinFlag = 'inner';\n    this._boolFlag = 'and';\n    this._notFlag = false;\n    this._asColumnFlag = false;\n  }\n\n  toString() {\n    return this.toQuery();\n  }\n\n  // Convert the current query \"toSQL\"\n  toSQL(method, tz) {\n    return this.client.queryCompiler(this).toSQL(method || this._method, tz);\n  }\n\n  // Create a shallow clone of the current query builder.\n  clone() {\n    const cloned = new this.constructor(this.client);\n    cloned._method = this._method;\n    cloned._single = clone(this._single);\n    cloned._statements = clone(this._statements);\n    cloned._debug = this._debug;\n\n    // `_option` is assigned by the `Interface` mixin.\n    if (this._options !== undefined) {\n      cloned._options = clone(this._options);\n    }\n    if (this._queryContext !== undefined) {\n      cloned._queryContext = clone(this._queryContext);\n    }\n    if (this._connection !== undefined) {\n      cloned._connection = this._connection;\n    }\n\n    return cloned;\n  }\n\n  timeout(ms, { cancel } = {}) {\n    if (isNumber(ms) && ms > 0) {\n      this._timeout = ms;\n      if (cancel) {\n        this.client.assertCanCancelQuery();\n        this._cancelOnTimeout = true;\n      }\n    }\n    return this;\n  }\n\n  // With\n  // ------\n  isValidStatementArg(statement) {\n    return (\n      typeof statement === 'function' ||\n      statement instanceof Builder ||\n      (statement && statement.isRawInstance)\n    );\n  }\n\n  _validateWithArgs(alias, statementOrColumnList, nothingOrStatement, method) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    if (typeof alias !== 'string') {\n      throw new Error(`${method}() first argument must be a string`);\n    }\n\n    if (this.isValidStatementArg(query) && typeof columnList === 'undefined') {\n      // Validated as two-arg variant (alias, statement).\n      return;\n    }\n\n    // Attempt to interpret as three-arg variant (alias, columnList, statement).\n    const isNonEmptyNameList =\n      Array.isArray(columnList) &&\n      columnList.length > 0 &&\n      columnList.every((it) => typeof it === 'string');\n    if (!isNonEmptyNameList) {\n      throw new Error(\n        `${method}() second argument must be a statement or non-empty column name list.`\n      );\n    }\n\n    if (this.isValidStatementArg(query)) {\n      return;\n    }\n    throw new Error(\n      `${method}() third argument must be a function / QueryBuilder or a raw when its second argument is a column name list`\n    );\n  }\n\n  with(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'with'\n    );\n    return this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n  }\n\n  withMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  withNotMaterialized(alias, statementOrColumnList, nothingOrStatement) {\n    throw new Error('With materialized is not supported by this dialect');\n  }\n\n  // Helper for compiling any advanced `with` queries.\n  withWrapped(alias, statementOrColumnList, nothingOrStatement, materialized) {\n    const [query, columnList] =\n      typeof nothingOrStatement === 'undefined'\n        ? [statementOrColumnList, undefined]\n        : [nothingOrStatement, statementOrColumnList];\n    const statement = {\n      grouping: 'with',\n      type: 'withWrapped',\n      alias: alias,\n      columnList,\n      value: query,\n    };\n    if (materialized !== undefined) {\n      statement.materialized = materialized;\n    }\n    this._statements.push(statement);\n    return this;\n  }\n\n  // With Recursive\n  // ------\n\n  withRecursive(alias, statementOrColumnList, nothingOrStatement) {\n    this._validateWithArgs(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement,\n      'withRecursive'\n    );\n    return this.withRecursiveWrapped(\n      alias,\n      statementOrColumnList,\n      nothingOrStatement\n    );\n  }\n\n  // Helper for compiling any advanced `withRecursive` queries.\n  withRecursiveWrapped(alias, statementOrColumnList, nothingOrStatement) {\n    this.withWrapped(alias, statementOrColumnList, nothingOrStatement);\n    this._statements[this._statements.length - 1].recursive = true;\n    return this;\n  }\n\n  // Select\n  // ------\n\n  // Adds a column or columns to the list of \"columns\"\n  // being selected on the query.\n  columns(column) {\n    if (!column && column !== 0) return this;\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Allow for a sub-select to be explicitly aliased as a column,\n  // without needing to compile the query in a where.\n  as(column) {\n    this._single.as = column;\n    return this;\n  }\n\n  // Adds a single hint or an array of hits to the list of \"hintComments\" on the query.\n  hintComment(hints) {\n    hints = Array.isArray(hints) ? hints : [hints];\n    if (hints.some((hint) => !isString(hint))) {\n      throw new Error('Hint comment must be a string');\n    }\n    if (hints.some((hint) => hint.includes('/*') || hint.includes('*/'))) {\n      throw new Error('Hint comment cannot include \"/*\" or \"*/\"');\n    }\n    if (hints.some((hint) => hint.includes('?'))) {\n      throw new Error('Hint comment cannot include \"?\"');\n    }\n    this._statements.push({\n      grouping: 'hintComments',\n      value: hints,\n    });\n    return this;\n  }\n\n  // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.\n  withSchema(schemaName) {\n    this._single.schema = schemaName;\n    return this;\n  }\n\n  // Sets the `tableName` on the query.\n  // Alias to \"from\" for select and \"into\" for insert statements\n  // e.g. builder.insert({a: value}).into('tableName')\n  // `options`: options object containing keys:\n  //   - `only`: whether the query should use SQL's ONLY to not return\n  //           inheriting table data. Defaults to false.\n  table(tableName, options = {}) {\n    this._single.table = tableName;\n    this._single.only = options.only === true;\n    return this;\n  }\n\n  // Adds a `distinct` clause to the query.\n  distinct(...args) {\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinct: true,\n    });\n    return this;\n  }\n\n  distinctOn(...args) {\n    if (isEmpty(args)) {\n      throw new Error('distinctOn requires at least on argument');\n    }\n    this._statements.push({\n      grouping: 'columns',\n      value: normalizeArr(...args),\n      distinctOn: true,\n    });\n    return this;\n  }\n\n  // Adds a join clause to the query, allowing for advanced joins\n  // with an anonymous function as the second argument.\n  join(table, first, ...args) {\n    let join;\n    const schema =\n      table instanceof Builder || typeof table === 'function'\n        ? undefined\n        : this._single.schema;\n    const joinType = this._joinType();\n    if (typeof first === 'function') {\n      join = new JoinClause(table, joinType, schema);\n      first.call(join, join);\n    } else if (joinType === 'raw') {\n      join = new JoinClause(this.client.raw(table, first), 'raw');\n    } else {\n      join = new JoinClause(table, joinType, schema);\n      if (first) {\n        join.on(first, ...args);\n      }\n    }\n    this._statements.push(join);\n    return this;\n  }\n\n  using(tables) {\n    throw new Error(\n      \"'using' function is only available in PostgreSQL dialect with Delete statements.\"\n    );\n  }\n\n  // JOIN blocks:\n  innerJoin(...args) {\n    return this._joinType('inner').join(...args);\n  }\n\n  leftJoin(...args) {\n    return this._joinType('left').join(...args);\n  }\n\n  leftOuterJoin(...args) {\n    return this._joinType('left outer').join(...args);\n  }\n\n  rightJoin(...args) {\n    return this._joinType('right').join(...args);\n  }\n\n  rightOuterJoin(...args) {\n    return this._joinType('right outer').join(...args);\n  }\n\n  outerJoin(...args) {\n    return this._joinType('outer').join(...args);\n  }\n\n  fullOuterJoin(...args) {\n    return this._joinType('full outer').join(...args);\n  }\n\n  crossJoin(...args) {\n    return this._joinType('cross').join(...args);\n  }\n\n  joinRaw(...args) {\n    return this._joinType('raw').join(...args);\n  }\n\n  // Where modifiers:\n  get or() {\n    return this._bool('or');\n  }\n\n  get not() {\n    return this._not(true);\n  }\n\n  // The where function can be used in several ways:\n  // The most basic is `where(key, value)`, which expands to\n  // where key = value.\n  where(column, operator, value) {\n    const argsLength = arguments.length;\n\n    // Support \"where true || where false\"\n    if (column === false || column === true) {\n      return this.where(1, '=', column ? 1 : 0);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a where statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.whereWrapped(column);\n    }\n\n    // Allows `where({id: 2})` syntax.\n    if (isObject(column) && !column.isRawInstance)\n      return this._objectWhere(column);\n\n    // Allow a raw statement to be passed along to the query.\n    if (column && column.isRawInstance && argsLength === 1)\n      return this.whereRaw(column);\n\n    // Enable the where('key', value) syntax, only when there\n    // are explicitly two arguments passed, so it's not possible to\n    // do where('key', '!=') and have that turn into where key != null\n    if (argsLength === 2) {\n      value = operator;\n      operator = '=';\n\n      // If the value is null, and it's a two argument query,\n      // we assume we're going for a `whereNull`.\n      if (value === null) {\n        return this.whereNull(column);\n      }\n    }\n\n    // lower case the operator for comparison purposes\n    const checkOperator = `${operator}`.toLowerCase().trim();\n\n    // If there are 3 arguments, check whether 'in' is one of them.\n    if (argsLength === 3) {\n      if (checkOperator === 'in' || checkOperator === 'not in') {\n        return this._not(checkOperator === 'not in').whereIn(column, value);\n      }\n      if (checkOperator === 'between' || checkOperator === 'not between') {\n        return this._not(checkOperator === 'not between').whereBetween(\n          column,\n          value\n        );\n      }\n    }\n\n    // If the value is still null, check whether they're meaning\n    // where value is null\n    if (value === null) {\n      // Check for .where(key, 'is', null) or .where(key, 'is not', 'null');\n      if (checkOperator === 'is' || checkOperator === 'is not') {\n        return this._not(checkOperator === 'is not').whereNull(column);\n      }\n    }\n\n    // Push onto the where statement stack.\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBasic',\n      column,\n      operator,\n      value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  whereColumn(...args) {\n    this._asColumnFlag = true;\n    this.where(...args);\n    this._asColumnFlag = false;\n    return this;\n  }\n\n  // Adds an `or where` clause to the query.\n  orWhere(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhere(key, obj[key]);\n        }\n      });\n    }\n    return this.where(column, ...args);\n  }\n\n  orWhereColumn(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.whereWrapped(function () {\n        for (const key in obj) {\n          this.andWhereColumn(key, '=', obj[key]);\n        }\n      });\n    }\n    return this.whereColumn(column, ...args);\n  }\n\n  // Adds an `not where` clause to the query.\n  whereNot(column, ...args) {\n    if (args.length >= 2) {\n      if (args[0] === 'in' || args[0] === 'between') {\n        this.client.logger.warn(\n          'whereNot is not suitable for \"in\" and \"between\" type subqueries. You should use \"not in\" and \"not between\" instead.'\n        );\n      }\n    }\n    return this._not(true).where(column, ...args);\n  }\n\n  whereNotColumn(...args) {\n    return this._not(true).whereColumn(...args);\n  }\n\n  // Adds an `or not where` clause to the query.\n  orWhereNot(...args) {\n    return this._bool('or').whereNot(...args);\n  }\n\n  orWhereNotColumn(...args) {\n    return this._bool('or').whereNotColumn(...args);\n  }\n\n  // Processes an object literal provided in a \"where\" clause.\n  _objectWhere(obj) {\n    const boolVal = this._bool();\n    const notVal = this._not() ? 'Not' : '';\n    for (const key in obj) {\n      this[boolVal + 'Where' + notVal](key, obj[key]);\n    }\n    return this;\n  }\n\n  // Adds a raw `where` clause to the query.\n  whereRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereRaw',\n      value: raw,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orWhereRaw(sql, bindings) {\n    return this._bool('or').whereRaw(sql, bindings);\n  }\n\n  // Helper for compiling any advanced `where` queries.\n  whereWrapped(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereWrapped',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where exists` clause to the query.\n  whereExists(callback) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds an `or where exists` clause to the query.\n  orWhereExists(callback) {\n    return this._bool('or').whereExists(callback);\n  }\n\n  // Adds a `where not exists` clause to the query.\n  whereNotExists(callback) {\n    return this._not(true).whereExists(callback);\n  }\n\n  // Adds a `or where not exists` clause to the query.\n  orWhereNotExists(callback) {\n    return this._bool('or').whereNotExists(callback);\n  }\n\n  // Adds a `where in` clause to the query.\n  whereIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orWhereIn(column, values) {\n    return this._bool('or').whereIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  whereNotIn(column, values) {\n    return this._not(true).whereIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orWhereNotIn(column, values) {\n    return this._bool('or')._not(true).whereIn(column, values);\n  }\n\n  // Adds a `where null` clause to the query.\n  whereNull(column) {\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where null` clause to the query.\n  orWhereNull(column) {\n    return this._bool('or').whereNull(column);\n  }\n\n  // Adds a `where not null` clause to the query.\n  whereNotNull(column) {\n    return this._not(true).whereNull(column);\n  }\n\n  // Adds a `or where not null` clause to the query.\n  orWhereNotNull(column) {\n    return this._bool('or').whereNotNull(column);\n  }\n\n  // Adds a `where between` clause to the query.\n  whereBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to whereBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the whereBetween clause'\n    );\n    this._statements.push({\n      grouping: 'where',\n      type: 'whereBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `where not between` clause to the query.\n  whereNotBetween(column, values) {\n    return this._not(true).whereBetween(column, values);\n  }\n\n  // Adds a `or where between` clause to the query.\n  orWhereBetween(column, values) {\n    return this._bool('or').whereBetween(column, values);\n  }\n\n  // Adds a `or where not between` clause to the query.\n  orWhereNotBetween(column, values) {\n    return this._bool('or').whereNotBetween(column, values);\n  }\n\n  _whereLike(type, column, value) {\n    this._statements.push({\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    });\n    return this;\n  }\n\n  // Adds a `where like` clause to the query.\n  whereLike(column, value) {\n    return this._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `or where like` clause to the query.\n  orWhereLike(column, value) {\n    return this._bool('or')._whereLike('whereLike', column, value);\n  }\n\n  // Adds a `where ilike` clause to the query.\n  whereILike(column, value) {\n    return this._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `or where ilike` clause to the query.\n  orWhereILike(column, value) {\n    return this._bool('or')._whereLike('whereILike', column, value);\n  }\n\n  // Adds a `group by` clause to the query.\n  groupBy(item) {\n    if (item && item.isRawInstance) {\n      return this.groupByRaw.apply(this, arguments);\n    }\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByBasic',\n      value: normalizeArr(...arguments),\n    });\n    return this;\n  }\n\n  // Adds a raw `group by` clause to the query.\n  groupByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'group',\n      type: 'groupByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  // Adds a `order by` clause to the query.\n  orderBy(column, direction, nulls = '') {\n    if (Array.isArray(column)) {\n      return this._orderByArray(column);\n    }\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByBasic',\n      value: column,\n      direction,\n      nulls,\n    });\n    return this;\n  }\n\n  // Adds a `order by` with multiple columns to the query.\n  _orderByArray(columnDefs) {\n    for (let i = 0; i < columnDefs.length; i++) {\n      const columnInfo = columnDefs[i];\n      if (isObject(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo['column'],\n          direction: columnInfo['order'],\n          nulls: columnInfo['nulls'],\n        });\n      } else if (isString(columnInfo)) {\n        this._statements.push({\n          grouping: 'order',\n          type: 'orderByBasic',\n          value: columnInfo,\n        });\n      }\n    }\n    return this;\n  }\n\n  // Add a raw `order by` clause to the query.\n  orderByRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'order',\n      type: 'orderByRaw',\n      value: raw,\n    });\n    return this;\n  }\n\n  _union(clause, args) {\n    let callbacks = args[0];\n    let wrap = args[1];\n    if (args.length === 1 || (args.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: clause,\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(args).slice(0, args.length - 1);\n      wrap = args[args.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this._union(clause, [callbacks, wrap]);\n    }\n    return this;\n  }\n\n  // Add a union statement to the query.\n  union(...args) {\n    return this._union('union', args);\n  }\n\n  // Adds a union all statement to the query.\n  unionAll(...args) {\n    return this._union('union all', args);\n  }\n\n  // Adds an intersect statement to the query\n  intersect(callbacks, wrap) {\n    if (arguments.length === 1 || (arguments.length === 2 && isBoolean(wrap))) {\n      if (!Array.isArray(callbacks)) {\n        callbacks = [callbacks];\n      }\n      for (let i = 0, l = callbacks.length; i < l; i++) {\n        this._statements.push({\n          grouping: 'union',\n          clause: 'intersect',\n          value: callbacks[i],\n          wrap: wrap || false,\n        });\n      }\n    } else {\n      callbacks = toArray(arguments).slice(0, arguments.length - 1);\n      wrap = arguments[arguments.length - 1];\n      if (!isBoolean(wrap)) {\n        callbacks.push(wrap);\n        wrap = false;\n      }\n      this.intersect(callbacks, wrap);\n    }\n    return this;\n  }\n\n  // Adds a `having` clause to the query.\n  having(column, operator, value) {\n    if (column.isRawInstance && arguments.length === 1) {\n      return this.havingRaw(column);\n    }\n\n    // Check if the column is a function, in which case it's\n    // a having statement wrapped in parens.\n    if (typeof column === 'function') {\n      return this.havingWrapped(column);\n    }\n\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBasic',\n      column,\n      operator,\n      value,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHaving(column, ...args) {\n    this._bool('or');\n    const obj = column;\n    if (isObject(obj) && !obj.isRawInstance) {\n      return this.havingWrapped(function () {\n        for (const key in obj) {\n          this.andHaving(key, obj[key]);\n        }\n      });\n    }\n    return this.having(column, ...args);\n  }\n\n  // Helper for compiling any advanced `having` queries.\n  havingWrapped(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingWrapped',\n      value: callback,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  havingNull(column) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingNull',\n      column,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingNull(callback) {\n    return this._bool('or').havingNull(callback);\n  }\n\n  havingNotNull(callback) {\n    return this._not(true).havingNull(callback);\n  }\n\n  orHavingNotNull(callback) {\n    return this._not(true)._bool('or').havingNull(callback);\n  }\n\n  havingExists(callback) {\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingExists',\n      value: callback,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingExists(callback) {\n    return this._bool('or').havingExists(callback);\n  }\n\n  havingNotExists(callback) {\n    return this._not(true).havingExists(callback);\n  }\n\n  orHavingNotExists(callback) {\n    return this._not(true)._bool('or').havingExists(callback);\n  }\n\n  havingBetween(column, values) {\n    assert(\n      Array.isArray(values),\n      'The second argument to havingBetween must be an array.'\n    );\n    assert(\n      values.length === 2,\n      'You must specify 2 values for the havingBetween clause'\n    );\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingBetween',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  orHavingBetween(column, values) {\n    return this._bool('or').havingBetween(column, values);\n  }\n\n  havingNotBetween(column, values) {\n    return this._not(true).havingBetween(column, values);\n  }\n\n  orHavingNotBetween(column, values) {\n    return this._not(true)._bool('or').havingBetween(column, values);\n  }\n\n  havingIn(column, values) {\n    if (Array.isArray(values) && isEmpty(values))\n      return this.where(this._not());\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingIn',\n      column,\n      value: values,\n      not: this._not(),\n      bool: this._bool(),\n    });\n    return this;\n  }\n\n  // Adds a `or where in` clause to the query.\n  orHavingIn(column, values) {\n    return this._bool('or').havingIn(column, values);\n  }\n\n  // Adds a `where not in` clause to the query.\n  havingNotIn(column, values) {\n    return this._not(true).havingIn(column, values);\n  }\n\n  // Adds a `or where not in` clause to the query.\n  orHavingNotIn(column, values) {\n    return this._bool('or')._not(true).havingIn(column, values);\n  }\n\n  // Adds a raw `having` clause to the query.\n  havingRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    this._statements.push({\n      grouping: 'having',\n      type: 'havingRaw',\n      value: raw,\n      bool: this._bool(),\n      not: this._not(),\n    });\n    return this;\n  }\n\n  orHavingRaw(sql, bindings) {\n    return this._bool('or').havingRaw(sql, bindings);\n  }\n\n  // set the skip binding parameter (= insert the raw value in the query) for an attribute.\n  _setSkipBinding(attribute, options) {\n    let skipBinding = options;\n    if (isObject(options)) {\n      skipBinding = options.skipBinding;\n    }\n    this._single.skipBinding = this._single.skipBinding || {};\n    this._single.skipBinding[attribute] = skipBinding;\n  }\n\n  // Only allow a single \"offset\" to be set for the current query.\n  offset(value, options) {\n    if (value == null || value.isRawInstance || value instanceof Builder) {\n      // Builder for backward compatibility\n      this._single.offset = value;\n    } else {\n      const val = parseInt(value, 10);\n      if (isNaN(val)) {\n        this.client.logger.warn('A valid integer must be provided to offset');\n      } else if (val < 0) {\n        throw new Error(`A non-negative integer must be provided to offset.`);\n      } else {\n        this._single.offset = val;\n      }\n    }\n    this._setSkipBinding('offset', options);\n    return this;\n  }\n\n  // Only allow a single \"limit\" to be set for the current query.\n  limit(value, options) {\n    const val = parseInt(value, 10);\n    if (isNaN(val)) {\n      this.client.logger.warn('A valid integer must be provided to limit');\n    } else {\n      this._single.limit = val;\n      this._setSkipBinding('limit', options);\n    }\n    return this;\n  }\n\n  // Retrieve the \"count\" result of the query.\n  count(column, options) {\n    return this._aggregate('count', column || '*', options);\n  }\n\n  // Retrieve the minimum value of a given column.\n  min(column, options) {\n    return this._aggregate('min', column, options);\n  }\n\n  // Retrieve the maximum value of a given column.\n  max(column, options) {\n    return this._aggregate('max', column, options);\n  }\n\n  // Retrieve the sum of the values of a given column.\n  sum(column, options) {\n    return this._aggregate('sum', column, options);\n  }\n\n  // Retrieve the average of the values of a given column.\n  avg(column, options) {\n    return this._aggregate('avg', column, options);\n  }\n\n  // Retrieve the \"count\" of the distinct results of the query.\n  countDistinct(...columns) {\n    let options;\n    if (columns.length > 1 && isPlainObject(last(columns))) {\n      [options] = columns.splice(columns.length - 1, 1);\n    }\n\n    if (!columns.length) {\n      columns = '*';\n    } else if (columns.length === 1) {\n      columns = columns[0];\n    }\n\n    return this._aggregate('count', columns, { ...options, distinct: true });\n  }\n\n  // Retrieve the sum of the distinct values of a given column.\n  sumDistinct(column, options) {\n    return this._aggregate('sum', column, { ...options, distinct: true });\n  }\n\n  // Retrieve the vg of the distinct results of the query.\n  avgDistinct(column, options) {\n    return this._aggregate('avg', column, { ...options, distinct: true });\n  }\n\n  // Increments a column's value by the specified amount.\n  increment(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, amount);\n  }\n\n  // Decrements a column's value by the specified amount.\n  decrement(column, amount = 1) {\n    if (isObject(column)) {\n      for (const key in column) {\n        this._counter(key, -column[key]);\n      }\n\n      return this;\n    }\n\n    return this._counter(column, -amount);\n  }\n\n  // Clears increments/decrements\n  clearCounters() {\n    this._single.counter = {};\n    return this;\n  }\n\n  // Sets the values for a `select` query, informing that only the first\n  // row should be returned (limit 1).\n  first(...args) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .first() on \"${this._method}\" query`);\n    }\n\n    this.select(normalizeArr(...args));\n    this._method = 'first';\n    this.limit(1);\n    return this;\n  }\n\n  // Use existing connection to execute the query\n  // Same value that client.acquireConnection() for an according client returns should be passed\n  connection(_connection) {\n    this._connection = _connection;\n    this.client.processPassedConnection(_connection);\n    return this;\n  }\n\n  // Pluck a column from a query.\n  pluck(column) {\n    if (this._method && this._method !== 'select') {\n      throw new Error(`Cannot chain .pluck() on \"${this._method}\" query`);\n    }\n\n    this._method = 'pluck';\n    this._single.pluck = column;\n    this._statements.push({\n      grouping: 'columns',\n      type: 'pluck',\n      value: column,\n    });\n    return this;\n  }\n\n  // Deprecated. Remove everything from select clause\n  clearSelect() {\n    this._clearGrouping('columns');\n    return this;\n  }\n\n  // Deprecated. Remove everything from where clause\n  clearWhere() {\n    this._clearGrouping('where');\n    return this;\n  }\n\n  // Deprecated. Remove everything from group clause\n  clearGroup() {\n    this._clearGrouping('group');\n    return this;\n  }\n\n  // Deprecated. Remove everything from order clause\n  clearOrder() {\n    this._clearGrouping('order');\n    return this;\n  }\n\n  // Deprecated. Remove everything from having clause\n  clearHaving() {\n    this._clearGrouping('having');\n    return this;\n  }\n\n  // Remove everything from statement clause\n  clear(statement) {\n    if (!CLEARABLE_STATEMENTS.has(statement))\n      throw new Error(`Knex Error: unknown statement '${statement}'`);\n    if (statement.startsWith('counter')) return this.clearCounters();\n    if (statement === 'select') {\n      statement = 'columns';\n    }\n    this._clearGrouping(statement);\n    return this;\n  }\n\n  // Insert & Update\n  // ------\n\n  // Sets the values for an `insert` query.\n  insert(values, returning, options) {\n    this._method = 'insert';\n    if (!isEmpty(returning)) this.returning(returning, options);\n    this._single.insert = values;\n    return this;\n  }\n\n  // Sets the values for an `update`, allowing for both\n  // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.\n  update(values, returning, options) {\n    let ret;\n    const obj = this._single.update || {};\n    this._method = 'update';\n    if (isString(values)) {\n      if (isPlainObject(returning)) {\n        obj[values] = JSON.stringify(returning);\n      } else {\n        obj[values] = returning;\n      }\n      if (arguments.length > 2) {\n        ret = arguments[2];\n      }\n    } else {\n      const keys = Object.keys(values);\n      if (this._single.update) {\n        this.client.logger.warn('Update called multiple times with objects.');\n      }\n      let i = -1;\n      while (++i < keys.length) {\n        obj[keys[i]] = values[keys[i]];\n      }\n      ret = arguments[1];\n    }\n    if (!isEmpty(ret)) this.returning(ret, options);\n    this._single.update = obj;\n    return this;\n  }\n\n  // Sets the returning value for the query.\n  returning(returning, options) {\n    this._single.returning = returning;\n    this._single.options = options;\n    return this;\n  }\n\n  onConflict(columns) {\n    if (typeof columns === 'string') {\n      columns = [columns];\n    }\n    return new OnConflictBuilder(this, columns || true);\n  }\n\n  // Delete\n  // ------\n\n  // Executes a delete statement on the query;\n  delete(ret, options) {\n    this._method = 'del';\n    if (!isEmpty(ret)) this.returning(ret, options);\n    return this;\n  }\n\n  // Truncates a table, ends the query chain.\n  truncate(tableName) {\n    this._method = 'truncate';\n    if (tableName) {\n      this._single.table = tableName;\n    }\n    return this;\n  }\n\n  // Retrieves columns for the table specified by `knex(tableName)`\n  columnInfo(column) {\n    this._method = 'columnInfo';\n    this._single.columnInfo = column;\n    return this;\n  }\n\n  // Set a lock for update constraint.\n  forUpdate(...tables) {\n    this._single.lock = lockMode.forUpdate;\n    if (tables.length === 1 && Array.isArray(tables[0])) {\n      this._single.lockTables = tables[0];\n    } else {\n      this._single.lockTables = tables;\n    }\n    return this;\n  }\n\n  // Set a lock for share constraint.\n  forShare(...tables) {\n    this._single.lock = lockMode.forShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for no key update constraint.\n  forNoKeyUpdate(...tables) {\n    this._single.lock = lockMode.forNoKeyUpdate;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Set a lock for key share constraint.\n  forKeyShare(...tables) {\n    this._single.lock = lockMode.forKeyShare;\n    this._single.lockTables = tables;\n    return this;\n  }\n\n  // Skips locked rows when using a lock constraint.\n  skipLocked() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .skipLocked() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.skipLocked() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.noWait) {\n      throw new Error('.skipLocked() cannot be used together with .noWait()!');\n    }\n    this._single.waitMode = waitMode.skipLocked;\n    return this;\n  }\n\n  // Causes error when acessing a locked row instead of waiting for it to be released.\n  noWait() {\n    if (!this._isSelectQuery()) {\n      throw new Error(`Cannot chain .noWait() on \"${this._method}\" query!`);\n    }\n    if (!this._hasLockMode()) {\n      throw new Error(\n        '.noWait() can only be used after a call to .forShare() or .forUpdate()!'\n      );\n    }\n    if (this._single.waitMode === waitMode.skipLocked) {\n      throw new Error('.noWait() cannot be used together with .skipLocked()!');\n    }\n    this._single.waitMode = waitMode.noWait;\n    return this;\n  }\n\n  // Takes a JS object of methods to call and calls them\n  fromJS(obj) {\n    each(obj, (val, key) => {\n      if (typeof this[key] !== 'function') {\n        this.client.logger.warn(`Knex Error: unknown key ${key}`);\n      }\n      if (Array.isArray(val)) {\n        this[key].apply(this, val);\n      } else {\n        this[key](val);\n      }\n    });\n    return this;\n  }\n\n  fromRaw(sql, bindings) {\n    const raw = sql.isRawInstance ? sql : this.client.raw(sql, bindings);\n    return this.from(raw);\n  }\n\n  // Passes query to provided callback function, useful for e.g. composing\n  // domain-specific helpers\n  modify(callback) {\n    callback.apply(this, [this].concat(tail(arguments)));\n    return this;\n  }\n\n  upsert(values, returning, options) {\n    throw new Error(\n      `Upsert is not yet supported for dialect ${this.client.dialect}`\n    );\n  }\n\n  // JSON support functions\n  _json(nameFunction, params) {\n    this._statements.push({\n      grouping: 'columns',\n      type: 'json',\n      method: nameFunction,\n      params: params,\n    });\n    return this;\n  }\n\n  jsonExtract() {\n    const column = arguments[0];\n    let path;\n    let alias;\n    let singleValue = true;\n\n    // We use arguments to have the signatures :\n    // - column (string or array)\n    // - column + path\n    // - column + path + alias\n    // - column + path + alias + singleValue\n    // - column array + singleValue\n    if (arguments.length >= 2) {\n      path = arguments[1];\n    }\n    if (arguments.length >= 3) {\n      alias = arguments[2];\n    }\n    if (arguments.length === 4) {\n      singleValue = arguments[3];\n    }\n    if (\n      arguments.length === 2 &&\n      Array.isArray(arguments[0]) &&\n      isBoolean(arguments[1])\n    ) {\n      singleValue = arguments[1];\n    }\n    return this._json('jsonExtract', {\n      column: column,\n      path: path,\n      alias: alias,\n      singleValue, // boolean used only in MSSQL to use function for extract value instead of object/array.\n    });\n  }\n\n  jsonSet(column, path, value, alias) {\n    return this._json('jsonSet', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonInsert(column, path, value, alias) {\n    return this._json('jsonInsert', {\n      column: column,\n      path: path,\n      value: value,\n      alias: alias,\n    });\n  }\n\n  jsonRemove(column, path, alias) {\n    return this._json('jsonRemove', {\n      column: column,\n      path: path,\n      alias: alias,\n    });\n  }\n\n  // Wheres for JSON\n  _isJsonObject(jsonValue) {\n    return isObject(jsonValue) && !(jsonValue instanceof Builder);\n  }\n\n  _whereJsonWrappedValue(type, column, value) {\n    const whereJsonClause = {\n      grouping: 'where',\n      type: type,\n      column,\n      value: value,\n      not: this._not(),\n      bool: this._bool(),\n      asColumn: this._asColumnFlag,\n    };\n    if (arguments[3]) {\n      whereJsonClause.operator = arguments[3];\n    }\n    if (arguments[4]) {\n      whereJsonClause.jsonPath = arguments[4];\n    }\n    this._statements.push(whereJsonClause);\n  }\n\n  whereJsonObject(column, value) {\n    this._whereJsonWrappedValue('whereJsonObject', column, value);\n    return this;\n  }\n\n  orWhereJsonObject(column, value) {\n    return this._bool('or').whereJsonObject(column, value);\n  }\n\n  whereNotJsonObject(column, value) {\n    return this._not(true).whereJsonObject(column, value);\n  }\n\n  orWhereNotJsonObject(column, value) {\n    return this._bool('or').whereNotJsonObject(column, value);\n  }\n\n  whereJsonPath(column, path, operator, value) {\n    this._whereJsonWrappedValue('whereJsonPath', column, value, operator, path);\n    return this;\n  }\n\n  orWhereJsonPath(column, path, operator, value) {\n    return this._bool('or').whereJsonPath(column, path, operator, value);\n  }\n\n  // Json superset wheres\n  whereJsonSupersetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSupersetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSupersetOf(column, value) {\n    return this._not(true).whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonSupersetOf(column, value) {\n    return this._bool('or').whereJsonSupersetOf(column, value);\n  }\n\n  orWhereJsonNotSupersetOf(column, value) {\n    return this._bool('or').whereJsonNotSupersetOf(column, value);\n  }\n\n  // Json subset wheres\n  whereJsonSubsetOf(column, value) {\n    this._whereJsonWrappedValue('whereJsonSubsetOf', column, value);\n    return this;\n  }\n\n  whereJsonNotSubsetOf(column, value) {\n    return this._not(true).whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonSubsetOf(column, value) {\n    return this._bool('or').whereJsonSubsetOf(column, value);\n  }\n\n  orWhereJsonNotSubsetOf(column, value) {\n    return this._bool('or').whereJsonNotSubsetOf(column, value);\n  }\n\n  whereJsonHasNone(column, values) {\n    this._not(true).whereJsonHasAll(column, values);\n    return this;\n  }\n\n  // end of wheres for JSON\n\n  _analytic(alias, second, third) {\n    let analytic;\n    const { schema } = this._single;\n    const method = this._analyticMethod();\n    alias = typeof alias === 'string' ? alias : null;\n\n    assert(\n      typeof second === 'function' ||\n        second.isRawInstance ||\n        Array.isArray(second) ||\n        typeof second === 'string' ||\n        typeof second === 'object',\n      `The second argument to an analytic function must be either a function, a raw,\n       an array of string or object, an object or a single string.`\n    );\n\n    if (third) {\n      assert(\n        Array.isArray(third) ||\n          typeof third === 'string' ||\n          typeof third === 'object',\n        'The third argument to an analytic function must be either a string, an array of string or object or an object.'\n      );\n    }\n\n    if (isFunction(second)) {\n      analytic = new Analytic(method, schema, alias);\n      second.call(analytic, analytic);\n    } else if (second.isRawInstance) {\n      const raw = second;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        raw: raw,\n        alias: alias,\n      };\n    } else {\n      const order = !Array.isArray(second) ? [second] : second;\n      let partitions = third || [];\n      partitions = !Array.isArray(partitions) ? [partitions] : partitions;\n      analytic = {\n        grouping: 'columns',\n        type: 'analytic',\n        method: method,\n        order: order,\n        alias: alias,\n        partitions: partitions,\n      };\n    }\n    this._statements.push(analytic);\n    return this;\n  }\n\n  rank(...args) {\n    return this._analyticMethod('rank')._analytic(...args);\n  }\n\n  denseRank(...args) {\n    return this._analyticMethod('dense_rank')._analytic(...args);\n  }\n\n  rowNumber(...args) {\n    return this._analyticMethod('row_number')._analytic(...args);\n  }\n\n  // ----------------------------------------------------------------------\n\n  // Helper for the incrementing/decrementing queries.\n  _counter(column, amount) {\n    amount = parseFloat(amount);\n\n    this._method = 'update';\n\n    this._single.counter = this._single.counter || {};\n\n    this._single.counter[column] = amount;\n\n    return this;\n  }\n\n  // Helper to get or set the \"boolFlag\" value.\n  _bool(val) {\n    if (arguments.length === 1) {\n      this._boolFlag = val;\n      return this;\n    }\n    const ret = this._boolFlag;\n    this._boolFlag = 'and';\n    return ret;\n  }\n\n  // Helper to get or set the \"notFlag\" value.\n  _not(val) {\n    if (arguments.length === 1) {\n      this._notFlag = val;\n      return this;\n    }\n    const ret = this._notFlag;\n    this._notFlag = false;\n    return ret;\n  }\n\n  // Helper to get or set the \"joinFlag\" value.\n  _joinType(val) {\n    if (arguments.length === 1) {\n      this._joinFlag = val;\n      return this;\n    }\n    const ret = this._joinFlag || 'inner';\n    this._joinFlag = 'inner';\n    return ret;\n  }\n\n  _analyticMethod(val) {\n    if (arguments.length === 1) {\n      this._analyticFlag = val;\n      return this;\n    }\n    return this._analyticFlag || 'row_number';\n  }\n\n  // Helper for compiling any aggregate queries.\n  _aggregate(method, column, options = {}) {\n    this._statements.push({\n      grouping: 'columns',\n      type: column.isRawInstance ? 'aggregateRaw' : 'aggregate',\n      method,\n      value: column,\n      aggregateDistinct: options.distinct || false,\n      alias: options.as,\n    });\n    return this;\n  }\n\n  // Helper function for clearing or reseting a grouping type from the builder\n  _clearGrouping(grouping) {\n    if (grouping in this._single) {\n      this._single[grouping] = undefined;\n    } else {\n      this._statements = reject(this._statements, { grouping });\n    }\n  }\n\n  // Helper function that checks if the builder will emit a select query\n  _isSelectQuery() {\n    return SELECT_COMMANDS.has(this._method);\n  }\n\n  // Helper function that checks if the query has a lock mode set\n  _hasLockMode() {\n    return LOCK_MODES.has(this._single.lock);\n  }\n}\n\nBuilder.prototype.select = Builder.prototype.columns;\nBuilder.prototype.column = Builder.prototype.columns;\nBuilder.prototype.andWhereNot = Builder.prototype.whereNot;\nBuilder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;\nBuilder.prototype.andWhere = Builder.prototype.where;\nBuilder.prototype.andWhereColumn = Builder.prototype.whereColumn;\nBuilder.prototype.andWhereRaw = Builder.prototype.whereRaw;\nBuilder.prototype.andWhereBetween = Builder.prototype.whereBetween;\nBuilder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;\nBuilder.prototype.andWhereJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereNotJsonObject = Builder.prototype.whereJsonObject;\nBuilder.prototype.andWhereJsonPath = Builder.prototype.whereJsonPath;\nBuilder.prototype.andWhereLike = Builder.prototype.whereLike;\nBuilder.prototype.andWhereILike = Builder.prototype.whereILike;\nBuilder.prototype.andHaving = Builder.prototype.having;\nBuilder.prototype.andHavingIn = Builder.prototype.havingIn;\nBuilder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;\nBuilder.prototype.andHavingNull = Builder.prototype.havingNull;\nBuilder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;\nBuilder.prototype.andHavingExists = Builder.prototype.havingExists;\nBuilder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;\nBuilder.prototype.andHavingBetween = Builder.prototype.havingBetween;\nBuilder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;\nBuilder.prototype.from = Builder.prototype.table;\nBuilder.prototype.into = Builder.prototype.table;\nBuilder.prototype.del = Builder.prototype.delete;\n\n// Attach all of the top level promise methods that should be chainable.\naugmentWithBuilderInterface(Builder);\naddQueryContext(Builder);\n\nBuilder.extend = (methodName, fn) => {\n  if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {\n    throw new Error(\n      `Can't extend QueryBuilder with existing method ('${methodName}').`\n    );\n  }\n\n  assign(Builder.prototype, { [methodName]: fn });\n};\n\n// Sub-builder for onConflict clauses\nclass OnConflictBuilder {\n  constructor(builder, columns) {\n    this.builder = builder;\n    this._columns = columns;\n  }\n\n  // Sets insert query to ignore conflicts\n  ignore() {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.ignore = true;\n    return this.builder;\n  }\n\n  // Sets insert query to update on conflict\n  merge(updates) {\n    this.builder._single.onConflict = this._columns;\n    this.builder._single.merge = { updates };\n    return this.builder;\n  }\n\n  // Prevent\n  then() {\n    throw new Error(\n      'Incomplete onConflict clause. .onConflict() must be directly followed by either .merge() or .ignore()'\n    );\n  }\n}\n\nmodule.exports = Builder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}