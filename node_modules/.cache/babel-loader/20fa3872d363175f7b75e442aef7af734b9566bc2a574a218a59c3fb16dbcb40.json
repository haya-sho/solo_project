{"ast":null,"code":"const isPlainObject = require('lodash/isPlainObject');\nconst isTypedArray = require('lodash/isTypedArray');\nconst {\n  CLIENT_ALIASES\n} = require('../constants');\nconst {\n  isFunction\n} = require('./is');\n\n// Check if the first argument is an array, otherwise uses all arguments as an\n// array.\nfunction normalizeArr() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (Array.isArray(args[0])) {\n    return args[0];\n  }\n  return args;\n}\nfunction containsUndefined(mixed) {\n  let argContainsUndefined = false;\n  if (isTypedArray(mixed)) return false;\n  if (mixed && isFunction(mixed.toSQL)) {\n    //Any QueryBuilder or Raw will automatically be validated during compile.\n    return argContainsUndefined;\n  }\n  if (Array.isArray(mixed)) {\n    for (let i = 0; i < mixed.length; i++) {\n      if (argContainsUndefined) break;\n      argContainsUndefined = containsUndefined(mixed[i]);\n    }\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach(key => {\n      if (!argContainsUndefined) {\n        argContainsUndefined = containsUndefined(mixed[key]);\n      }\n    });\n  } else {\n    argContainsUndefined = mixed === undefined;\n  }\n  return argContainsUndefined;\n}\nfunction getUndefinedIndices(mixed) {\n  const indices = [];\n  if (Array.isArray(mixed)) {\n    mixed.forEach((item, index) => {\n      if (containsUndefined(item)) {\n        indices.push(index);\n      }\n    });\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach(key => {\n      if (containsUndefined(mixed[key])) {\n        indices.push(key);\n      }\n    });\n  } else {\n    indices.push(0);\n  }\n  return indices;\n}\nfunction addQueryContext(Target) {\n  // Stores or returns (if called with no arguments) context passed to\n  // wrapIdentifier and postProcessResponse hooks\n  Target.prototype.queryContext = function (context) {\n    if (context === undefined) {\n      return this._queryContext;\n    }\n    this._queryContext = context;\n    return this;\n  };\n}\nfunction resolveClientNameWithAliases(clientName) {\n  return CLIENT_ALIASES[clientName] || clientName;\n}\nfunction toNumber(val, fallback) {\n  if (val === undefined || val === null) return fallback;\n  const number = parseInt(val, 10);\n  return isNaN(number) ? fallback : number;\n}\nmodule.exports = {\n  addQueryContext,\n  containsUndefined,\n  getUndefinedIndices,\n  normalizeArr,\n  resolveClientNameWithAliases,\n  toNumber\n};","map":{"version":3,"names":["isPlainObject","require","isTypedArray","CLIENT_ALIASES","isFunction","normalizeArr","_len","arguments","length","args","Array","_key","isArray","containsUndefined","mixed","argContainsUndefined","toSQL","i","Object","keys","forEach","key","undefined","getUndefinedIndices","indices","item","index","push","addQueryContext","Target","prototype","queryContext","context","_queryContext","resolveClientNameWithAliases","clientName","toNumber","val","fallback","number","parseInt","isNaN","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/util/helpers.js"],"sourcesContent":["const isPlainObject = require('lodash/isPlainObject');\nconst isTypedArray = require('lodash/isTypedArray');\nconst { CLIENT_ALIASES } = require('../constants');\nconst { isFunction } = require('./is');\n\n// Check if the first argument is an array, otherwise uses all arguments as an\n// array.\nfunction normalizeArr(...args) {\n  if (Array.isArray(args[0])) {\n    return args[0];\n  }\n\n  return args;\n}\n\nfunction containsUndefined(mixed) {\n  let argContainsUndefined = false;\n\n  if (isTypedArray(mixed)) return false;\n\n  if (mixed && isFunction(mixed.toSQL)) {\n    //Any QueryBuilder or Raw will automatically be validated during compile.\n    return argContainsUndefined;\n  }\n\n  if (Array.isArray(mixed)) {\n    for (let i = 0; i < mixed.length; i++) {\n      if (argContainsUndefined) break;\n      argContainsUndefined = containsUndefined(mixed[i]);\n    }\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach((key) => {\n      if (!argContainsUndefined) {\n        argContainsUndefined = containsUndefined(mixed[key]);\n      }\n    });\n  } else {\n    argContainsUndefined = mixed === undefined;\n  }\n\n  return argContainsUndefined;\n}\n\nfunction getUndefinedIndices(mixed) {\n  const indices = [];\n\n  if (Array.isArray(mixed)) {\n    mixed.forEach((item, index) => {\n      if (containsUndefined(item)) {\n        indices.push(index);\n      }\n    });\n  } else if (isPlainObject(mixed)) {\n    Object.keys(mixed).forEach((key) => {\n      if (containsUndefined(mixed[key])) {\n        indices.push(key);\n      }\n    });\n  } else {\n    indices.push(0);\n  }\n\n  return indices;\n}\n\nfunction addQueryContext(Target) {\n  // Stores or returns (if called with no arguments) context passed to\n  // wrapIdentifier and postProcessResponse hooks\n  Target.prototype.queryContext = function (context) {\n    if (context === undefined) {\n      return this._queryContext;\n    }\n    this._queryContext = context;\n    return this;\n  };\n}\n\nfunction resolveClientNameWithAliases(clientName) {\n  return CLIENT_ALIASES[clientName] || clientName;\n}\n\nfunction toNumber(val, fallback) {\n  if (val === undefined || val === null) return fallback;\n  const number = parseInt(val, 10);\n  return isNaN(number) ? fallback : number;\n}\n\nmodule.exports = {\n  addQueryContext,\n  containsUndefined,\n  getUndefinedIndices,\n  normalizeArr,\n  resolveClientNameWithAliases,\n  toNumber,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}