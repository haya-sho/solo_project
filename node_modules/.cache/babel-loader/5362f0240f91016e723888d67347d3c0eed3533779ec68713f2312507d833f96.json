{"ast":null,"code":"// Transaction\n// -------\nconst {\n  EventEmitter\n} = require('events');\nconst Debug = require('debug');\nconst uniqueId = require('lodash/uniqueId');\nconst {\n  callbackify\n} = require('util');\nconst makeKnex = require('../knex-builder/make-knex');\nconst {\n  timeout,\n  KnexTimeoutError\n} = require('../util/timeout');\nconst finallyMixin = require('../util/finally-mixin');\nconst debug = Debug('knex:tx');\n\n// FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true\n  };\n}\n// These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\nconst validIsolationLevels = [\n// Doesn't really work in postgres, it treats it as read committed\n'read uncommitted', 'read committed', 'snapshot',\n// snapshot and repeatable read are basically the same, most \"repeatable\n// read\" implementations are actually \"snapshot\" also known as Multi Version\n// Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n// repeated reads for inserts as it uses a pessimistic locking system so\n// you should probably use 'snapshot' to stop read skew.\n'repeatable read',\n// mysql pretends to have serializable, but it is not\n'serializable'];\n\n// Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\nclass Transaction extends EventEmitter {\n  constructor(client, container) {\n    let config = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_CONFIG();\n    let outerTx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n    const txid = this.txid = uniqueId('trx');\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n    debug('%s: Starting %s transaction', txid, outerTx ? 'nested' : 'top level');\n\n    // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n    this._lastChild = Promise.resolve();\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();\n\n    // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n    const basePromise = _previousSibling.then(() => this._evaluateContainer(config, container));\n\n    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n    this._promise = basePromise.then(x => x);\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n  isCompleted() {\n    return this._completed || this.outerTx && this.outerTx.isCompleted() || false;\n  }\n  begin(conn) {\n    const runIsolationLevelQuery = this.isolationLevel ? this.query(conn, `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`) : Promise.resolve();\n    return runIsolationLevelQuery.then(() => this.query(conn, 'BEGIN;'));\n  }\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(`Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(validIsolationLevels)}`);\n    }\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n  rollbackTo(conn, error) {\n    return timeout(this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error), 5000).catch(err => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n  query(conn, sql, status, value) {\n    const q = this.trxClient.query(conn, sql).catch(err => {\n      status = 2;\n      value = err;\n      this._completed = true;\n      debug('%s error running transaction query', this.txid);\n    }).then(res => {\n      if (status === 1) {\n        this._resolver(value);\n      }\n      if (status === 2) {\n        if (value === undefined) {\n          if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n            this._resolver();\n            return;\n          }\n          value = new Error(`Transaction rejected with non-error: ${value}`);\n        }\n        this._rejecter(value);\n      }\n      return res;\n    });\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n    return q;\n  }\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, connection => {\n      const trxClient = this.trxClient = makeTxClient(this, this.client, connection);\n      const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n      init.then(() => {\n        return makeTransactor(this, connection, trxClient);\n      }).then(transactor => {\n        transactor.executionPromise = executionPromise;\n\n        // If we've returned a \"thenable\" from the transaction container, assume\n        // the rollback and commit are chained to this object's success / failure.\n        // Directly thrown errors are treated as automatic rollbacks.\n        let result;\n        try {\n          result = container(transactor);\n        } catch (err) {\n          result = Promise.reject(err);\n        }\n        if (result && result.then && typeof result.then === 'function') {\n          result.then(val => {\n            return transactor.commit(val);\n          }).catch(err => {\n            return transactor.rollback(err);\n          });\n        }\n        return null;\n      }).catch(e => {\n        return this._rejecter(e);\n      });\n      return executionPromise;\n    });\n  }\n\n  // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection = configConnection || (await this.client.acquireConnection());\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n  catch() {\n    return this._promise.catch(...arguments);\n  }\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n}\nfinallyMixin(Transaction.prototype);\n\n// The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n  transactor.context.withUserParams = () => {\n    throw new Error('Cannot set user params on a transaction - it can only inherit params from main knex instance');\n  };\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = {\n        doNotRejectOnRollback: true\n      };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n    return this._transaction(container, options, trx);\n  };\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n  if (trx.client.transacting) {\n    transactor.commit = value => trx.release(connection, value);\n    transactor.rollback = error => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = value => trx.commit(connection, value);\n    transactor.rollback = error => trx.rollback(connection, error);\n  }\n  transactor.isCompleted = () => trx.isCompleted();\n  return transactor;\n}\n\n// We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n  const _query = trxClient.query;\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  const _stream = trxClient.stream;\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection) throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n  return trxClient;\n}\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error('Transaction query already complete, run with DEBUG=knex:tx for more info');\n}\nmodule.exports = Transaction;","map":{"version":3,"names":["EventEmitter","require","Debug","uniqueId","callbackify","makeKnex","timeout","KnexTimeoutError","finallyMixin","debug","DEFAULT_CONFIG","userParams","doNotRejectOnRollback","validIsolationLevels","Transaction","constructor","client","container","config","arguments","length","undefined","outerTx","txid","logger","trxClient","_completed","_debug","isolationLevel","setIsolationLevel","_lastChild","Promise","resolve","_previousSibling","basePromise","then","_evaluateContainer","_promise","x","catch","isCompleted","begin","conn","runIsolationLevelQuery","query","savepoint","commit","value","release","includes","Error","JSON","stringify","rollback","error","err","reject","_rejecter","rollbackTo","sql","status","q","res","_resolver","test","enabled","acquireConnection","connection","makeTxClient","init","transacting","executionPromise","resolver","rejecter","makeTransactor","transactor","result","val","e","cb","configConnection","__knexTxId","releaseConnection","onResolve","onReject","asCallback","prototype","trx","context","withUserParams","isTransaction","transaction","options","_transaction","Object","create","version","driver","connectionSettings","valueForUndefined","on","arg","emit","obj","response","builder","_query","completed","completedError","call","_stream","stream","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/execution/transaction.js"],"sourcesContent":["// Transaction\n// -------\nconst { EventEmitter } = require('events');\nconst Debug = require('debug');\nconst uniqueId = require('lodash/uniqueId');\nconst { callbackify } = require('util');\n\nconst makeKnex = require('../knex-builder/make-knex');\nconst { timeout, KnexTimeoutError } = require('../util/timeout');\nconst finallyMixin = require('../util/finally-mixin');\n\nconst debug = Debug('knex:tx');\n\n// FYI: This is defined as a function instead of a constant so that\n//      each Transactor can have its own copy of the default config.\n//      This will minimize the impact of bugs that might be introduced\n//      if a Transactor ever mutates its config.\nfunction DEFAULT_CONFIG() {\n  return {\n    userParams: {},\n    doNotRejectOnRollback: true,\n  };\n}\n// These aren't supported in sqlite3 which is serialized already so it's as\n// safe as reasonable, except for a special read_uncommitted pragma\nconst validIsolationLevels = [\n  // Doesn't really work in postgres, it treats it as read committed\n  'read uncommitted',\n  'read committed',\n  'snapshot',\n  // snapshot and repeatable read are basically the same, most \"repeatable\n  // read\" implementations are actually \"snapshot\" also known as Multi Version\n  // Concurrency Control (MVCC). Mssql's repeatable read doesn't stop\n  // repeated reads for inserts as it uses a pessimistic locking system so\n  // you should probably use 'snapshot' to stop read skew.\n  'repeatable read',\n  // mysql pretends to have serializable, but it is not\n  'serializable',\n];\n\n// Acts as a facade for a Promise, keeping the internal state\n// and managing any child transactions.\nclass Transaction extends EventEmitter {\n  constructor(client, container, config = DEFAULT_CONFIG(), outerTx = null) {\n    super();\n    this.userParams = config.userParams;\n    this.doNotRejectOnRollback = config.doNotRejectOnRollback;\n\n    const txid = (this.txid = uniqueId('trx'));\n\n    this.client = client;\n    this.logger = client.logger;\n    this.outerTx = outerTx;\n    this.trxClient = undefined;\n    this._completed = false;\n    this._debug = client.config && client.config.debug;\n\n    if (config.isolationLevel) {\n      this.setIsolationLevel(config.isolationLevel);\n    }\n\n    debug(\n      '%s: Starting %s transaction',\n      txid,\n      outerTx ? 'nested' : 'top level'\n    );\n\n    // `this` can potentially serve as an `outerTx` for another\n    // Transaction.  So, go ahead and establish `_lastChild` now.\n    this._lastChild = Promise.resolve();\n\n    const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();\n\n    // FYI: As you will see in a moment, this Promise will be used to construct\n    //      2 separate Promise Chains.  This ensures that each Promise Chain\n    //      can establish its error-handling semantics without interfering\n    //      with the other Promise Chain.\n    const basePromise = _previousSibling.then(() =>\n      this._evaluateContainer(config, container)\n    );\n\n    // FYI: This is the Promise Chain for EXTERNAL use.  It ensures that the\n    //      caller must handle any exceptions that result from `basePromise`.\n    this._promise = basePromise.then((x) => x);\n\n    if (outerTx) {\n      // FYI: This is the Promise Chain for INTERNAL use.  It serves as a signal\n      //      for when the next sibling should begin its execution.  Therefore,\n      //      exceptions are caught and ignored.\n      outerTx._lastChild = basePromise.catch(() => {});\n    }\n  }\n\n  isCompleted() {\n    return (\n      this._completed || (this.outerTx && this.outerTx.isCompleted()) || false\n    );\n  }\n\n  begin(conn) {\n    const runIsolationLevelQuery = this.isolationLevel\n      ? this.query(\n          conn,\n          `SET TRANSACTION ISOLATION LEVEL ${this.isolationLevel};`\n        )\n      : Promise.resolve();\n    return runIsolationLevelQuery.then(() => this.query(conn, 'BEGIN;'));\n  }\n\n  savepoint(conn) {\n    return this.query(conn, `SAVEPOINT ${this.txid};`);\n  }\n\n  commit(conn, value) {\n    return this.query(conn, 'COMMIT;', 1, value);\n  }\n\n  release(conn, value) {\n    return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value);\n  }\n\n  setIsolationLevel(isolationLevel) {\n    if (!validIsolationLevels.includes(isolationLevel)) {\n      throw new Error(\n        `Invalid isolationLevel, supported isolation levels are: ${JSON.stringify(\n          validIsolationLevels\n        )}`\n      );\n    }\n    this.isolationLevel = isolationLevel;\n    return this;\n  }\n\n  rollback(conn, error) {\n    return timeout(this.query(conn, 'ROLLBACK', 2, error), 5000).catch(\n      (err) => {\n        if (!(err instanceof KnexTimeoutError)) {\n          return Promise.reject(err);\n        }\n        this._rejecter(error);\n      }\n    );\n  }\n\n  rollbackTo(conn, error) {\n    return timeout(\n      this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),\n      5000\n    ).catch((err) => {\n      if (!(err instanceof KnexTimeoutError)) {\n        return Promise.reject(err);\n      }\n      this._rejecter(error);\n    });\n  }\n\n  query(conn, sql, status, value) {\n    const q = this.trxClient\n      .query(conn, sql)\n      .catch((err) => {\n        status = 2;\n        value = err;\n        this._completed = true;\n        debug('%s error running transaction query', this.txid);\n      })\n      .then((res) => {\n        if (status === 1) {\n          this._resolver(value);\n        }\n        if (status === 2) {\n          if (value === undefined) {\n            if (this.doNotRejectOnRollback && /^ROLLBACK\\b/i.test(sql)) {\n              this._resolver();\n              return;\n            }\n\n            value = new Error(`Transaction rejected with non-error: ${value}`);\n          }\n          this._rejecter(value);\n        }\n        return res;\n      });\n    if (status === 1 || status === 2) {\n      this._completed = true;\n    }\n    return q;\n  }\n\n  debug(enabled) {\n    this._debug = arguments.length ? enabled : true;\n    return this;\n  }\n\n  async _evaluateContainer(config, container) {\n    return this.acquireConnection(config, (connection) => {\n      const trxClient = (this.trxClient = makeTxClient(\n        this,\n        this.client,\n        connection\n      ));\n      const init = this.client.transacting\n        ? this.savepoint(connection)\n        : this.begin(connection);\n      const executionPromise = new Promise((resolver, rejecter) => {\n        this._resolver = resolver;\n        this._rejecter = rejecter;\n      });\n\n      init\n        .then(() => {\n          return makeTransactor(this, connection, trxClient);\n        })\n        .then((transactor) => {\n          transactor.executionPromise = executionPromise;\n\n          // If we've returned a \"thenable\" from the transaction container, assume\n          // the rollback and commit are chained to this object's success / failure.\n          // Directly thrown errors are treated as automatic rollbacks.\n          let result;\n          try {\n            result = container(transactor);\n          } catch (err) {\n            result = Promise.reject(err);\n          }\n          if (result && result.then && typeof result.then === 'function') {\n            result\n              .then((val) => {\n                return transactor.commit(val);\n              })\n              .catch((err) => {\n                return transactor.rollback(err);\n              });\n          }\n          return null;\n        })\n        .catch((e) => {\n          return this._rejecter(e);\n        });\n\n      return executionPromise;\n    });\n  }\n\n  // Acquire a connection and create a disposer - either using the one passed\n  // via config or getting one off the client. The disposer will be called once\n  // the original promise is marked completed.\n  async acquireConnection(config, cb) {\n    const configConnection = config && config.connection;\n    const connection =\n      configConnection || (await this.client.acquireConnection());\n\n    try {\n      connection.__knexTxId = this.txid;\n      return await cb(connection);\n    } finally {\n      if (!configConnection) {\n        debug('%s: releasing connection', this.txid);\n        this.client.releaseConnection(connection);\n      } else {\n        debug('%s: not releasing external connection', this.txid);\n      }\n    }\n  }\n\n  then(onResolve, onReject) {\n    return this._promise.then(onResolve, onReject);\n  }\n\n  catch(...args) {\n    return this._promise.catch(...args);\n  }\n\n  asCallback(cb) {\n    callbackify(() => this._promise)(cb);\n    return this._promise;\n  }\n}\nfinallyMixin(Transaction.prototype);\n\n// The transactor is a full featured knex object, with a \"commit\", a \"rollback\"\n// and a \"savepoint\" function. The \"savepoint\" is just sugar for creating a new\n// transaction. If the rollback is run inside a savepoint, it rolls back to the\n// last savepoint - otherwise it rolls back the transaction.\nfunction makeTransactor(trx, connection, trxClient) {\n  const transactor = makeKnex(trxClient);\n\n  transactor.context.withUserParams = () => {\n    throw new Error(\n      'Cannot set user params on a transaction - it can only inherit params from main knex instance'\n    );\n  };\n\n  transactor.isTransaction = true;\n  transactor.userParams = trx.userParams || {};\n\n  transactor.context.transaction = function (container, options) {\n    if (!options) {\n      options = { doNotRejectOnRollback: true };\n    } else if (options.doNotRejectOnRollback === undefined) {\n      options.doNotRejectOnRollback = true;\n    }\n\n    return this._transaction(container, options, trx);\n  };\n\n  transactor.savepoint = function (container, options) {\n    return transactor.transaction(container, options);\n  };\n\n  if (trx.client.transacting) {\n    transactor.commit = (value) => trx.release(connection, value);\n    transactor.rollback = (error) => trx.rollbackTo(connection, error);\n  } else {\n    transactor.commit = (value) => trx.commit(connection, value);\n    transactor.rollback = (error) => trx.rollback(connection, error);\n  }\n\n  transactor.isCompleted = () => trx.isCompleted();\n\n  return transactor;\n}\n\n// We need to make a client object which always acquires the same\n// connection and does not release back into the pool.\nfunction makeTxClient(trx, client, connection) {\n  const trxClient = Object.create(client.constructor.prototype);\n  trxClient.version = client.version;\n  trxClient.config = client.config;\n  trxClient.driver = client.driver;\n  trxClient.connectionSettings = client.connectionSettings;\n  trxClient.transacting = true;\n  trxClient.valueForUndefined = client.valueForUndefined;\n  trxClient.logger = client.logger;\n\n  trxClient.on('start', function (arg) {\n    trx.emit('start', arg);\n    client.emit('start', arg);\n  });\n\n  trxClient.on('query', function (arg) {\n    trx.emit('query', arg);\n    client.emit('query', arg);\n  });\n\n  trxClient.on('query-error', function (err, obj) {\n    trx.emit('query-error', err, obj);\n    client.emit('query-error', err, obj);\n  });\n\n  trxClient.on('query-response', function (response, obj, builder) {\n    trx.emit('query-response', response, obj, builder);\n    client.emit('query-response', response, obj, builder);\n  });\n\n  const _query = trxClient.query;\n  trxClient.query = function (conn, obj) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_query.call(trxClient, conn, obj));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  const _stream = trxClient.stream;\n  trxClient.stream = function (conn, obj, stream, options) {\n    const completed = trx.isCompleted();\n    return new Promise(function (resolve, reject) {\n      try {\n        if (conn !== connection)\n          throw new Error('Invalid connection for transaction query.');\n        if (completed) completedError(trx, obj);\n        resolve(_stream.call(trxClient, conn, obj, stream, options));\n      } catch (e) {\n        reject(e);\n      }\n    });\n  };\n  trxClient.acquireConnection = function () {\n    return Promise.resolve(connection);\n  };\n  trxClient.releaseConnection = function () {\n    return Promise.resolve();\n  };\n\n  return trxClient;\n}\n\nfunction completedError(trx, obj) {\n  const sql = typeof obj === 'string' ? obj : obj && obj.sql;\n  debug('%s: Transaction completed: %s', trx.txid, sql);\n  throw new Error(\n    'Transaction query already complete, run with DEBUG=knex:tx for more info'\n  );\n}\n\nmodule.exports = Transaction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}