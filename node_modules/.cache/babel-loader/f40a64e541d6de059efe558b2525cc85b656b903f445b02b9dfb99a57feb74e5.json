{"ast":null,"code":"const utils = require('../../utils');\nconst trigger = {\n  renameColumnTrigger: function (logger, tableName, columnName, to) {\n    const triggerName = utils.generateCombinedName(logger, 'autoinc_trg', tableName);\n    const sequenceName = utils.generateCombinedName(logger, 'seq', tableName);\n    return `DECLARE ` + `PK_NAME VARCHAR(200); ` + `IS_AUTOINC NUMBER := 0; ` + `BEGIN` + `  EXECUTE IMMEDIATE ('ALTER TABLE \"${tableName}\" RENAME COLUMN \"${columnName}\" TO \"${to}\"');` + `  SELECT COUNT(*) INTO IS_AUTOINC from \"USER_TRIGGERS\" where trigger_name = '${triggerName}';` + `  IF (IS_AUTOINC > 0) THEN` + `    SELECT cols.column_name INTO PK_NAME` + `    FROM all_constraints cons, all_cons_columns cols` + `    WHERE cons.constraint_type = 'P'` + `    AND cons.constraint_name = cols.constraint_name` + `    AND cons.owner = cols.owner` + `    AND cols.table_name = '${tableName}';` + `    IF ('${to}' = PK_NAME) THEN` + `      EXECUTE IMMEDIATE ('DROP TRIGGER \"${triggerName}\"');` + `      EXECUTE IMMEDIATE ('create or replace trigger \"${triggerName}\"` + `      BEFORE INSERT on \"${tableName}\" for each row` + `        declare` + `        checking number := 1;` + `        begin` + `          if (:new.\"${to}\" is null) then` + `            while checking >= 1 loop` + `              select \"${sequenceName}\".nextval into :new.\"${to}\" from dual;` + `              select count(\"${to}\") into checking from \"${tableName}\"` + `              where \"${to}\" = :new.\"${to}\";` + `            end loop;` + `          end if;` + `        end;');` + `    end if;` + `  end if;` + `END;`;\n  },\n  createAutoIncrementTrigger: function (logger, tableName, schemaName) {\n    const tableQuoted = `\"${tableName}\"`;\n    const tableUnquoted = tableName;\n    const schemaQuoted = schemaName ? `\"${schemaName}\".` : '';\n    const constraintOwner = schemaName ? `'${schemaName}'` : 'cols.owner';\n    const triggerName = utils.generateCombinedName(logger, 'autoinc_trg', tableName);\n    const sequenceNameUnquoted = utils.generateCombinedName(logger, 'seq', tableName);\n    const sequenceNameQuoted = `\"${sequenceNameUnquoted}\"`;\n    return `DECLARE ` + `PK_NAME VARCHAR(200); ` + `BEGIN` + `  EXECUTE IMMEDIATE ('CREATE SEQUENCE ${schemaQuoted}${sequenceNameQuoted}');` + `  SELECT cols.column_name INTO PK_NAME` +\n    // TODO : support autoincrement on table with multiple primary keys\n    `  FROM all_constraints cons, all_cons_columns cols` + `  WHERE cons.constraint_type = 'P'` + `  AND cons.constraint_name = cols.constraint_name` + `  AND cons.owner = ${constraintOwner}` + `  AND cols.table_name = '${tableUnquoted}';` + `  execute immediate ('create or replace trigger ${schemaQuoted}\"${triggerName}\"` + `  BEFORE INSERT on ${schemaQuoted}${tableQuoted}` + `  for each row` + `  declare` + `  checking number := 1;` + `  begin` + `    if (:new.\"' || PK_NAME || '\" is null) then` + `      while checking >= 1 loop` + `        select ${schemaQuoted}${sequenceNameQuoted}.nextval into :new.\"' || PK_NAME || '\" from dual;` + `        select count(\"' || PK_NAME || '\") into checking from ${schemaQuoted}${tableQuoted}` + `        where \"' || PK_NAME || '\" = :new.\"' || PK_NAME || '\";` + `      end loop;` + `    end if;` + `  end;'); ` + `END;`;\n  },\n  renameTableAndAutoIncrementTrigger: function (logger, tableName, to) {\n    const triggerName = utils.generateCombinedName(logger, 'autoinc_trg', tableName);\n    const sequenceName = utils.generateCombinedName(logger, 'seq', tableName);\n    const toTriggerName = utils.generateCombinedName(logger, 'autoinc_trg', to);\n    const toSequenceName = utils.generateCombinedName(logger, 'seq', to);\n    return `DECLARE ` + `PK_NAME VARCHAR(200); ` + `IS_AUTOINC NUMBER := 0; ` + `BEGIN` + `  EXECUTE IMMEDIATE ('RENAME \"${tableName}\" TO \"${to}\"');` + `  SELECT COUNT(*) INTO IS_AUTOINC from \"USER_TRIGGERS\" where trigger_name = '${triggerName}';` + `  IF (IS_AUTOINC > 0) THEN` + `    EXECUTE IMMEDIATE ('DROP TRIGGER \"${triggerName}\"');` + `    EXECUTE IMMEDIATE ('RENAME \"${sequenceName}\" TO \"${toSequenceName}\"');` + `    SELECT cols.column_name INTO PK_NAME` + `    FROM all_constraints cons, all_cons_columns cols` + `    WHERE cons.constraint_type = 'P'` + `    AND cons.constraint_name = cols.constraint_name` + `    AND cons.owner = cols.owner` + `    AND cols.table_name = '${to}';` + `    EXECUTE IMMEDIATE ('create or replace trigger \"${toTriggerName}\"` + `    BEFORE INSERT on \"${to}\" for each row` + `      declare` + `      checking number := 1;` + `      begin` + `        if (:new.\"' || PK_NAME || '\" is null) then` + `          while checking >= 1 loop` + `            select \"${toSequenceName}\".nextval into :new.\"' || PK_NAME || '\" from dual;` + `            select count(\"' || PK_NAME || '\") into checking from \"${to}\"` + `            where \"' || PK_NAME || '\" = :new.\"' || PK_NAME || '\";` + `          end loop;` + `        end if;` + `      end;');` + `  end if;` + `END;`;\n  }\n};\nmodule.exports = trigger;","map":{"version":3,"names":["utils","require","trigger","renameColumnTrigger","logger","tableName","columnName","to","triggerName","generateCombinedName","sequenceName","createAutoIncrementTrigger","schemaName","tableQuoted","tableUnquoted","schemaQuoted","constraintOwner","sequenceNameUnquoted","sequenceNameQuoted","renameTableAndAutoIncrementTrigger","toTriggerName","toSequenceName","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/dialects/oracle/schema/internal/trigger.js"],"sourcesContent":["const utils = require('../../utils');\n\nconst trigger = {\n  renameColumnTrigger: function (logger, tableName, columnName, to) {\n    const triggerName = utils.generateCombinedName(\n      logger,\n      'autoinc_trg',\n      tableName\n    );\n    const sequenceName = utils.generateCombinedName(logger, 'seq', tableName);\n    return (\n      `DECLARE ` +\n      `PK_NAME VARCHAR(200); ` +\n      `IS_AUTOINC NUMBER := 0; ` +\n      `BEGIN` +\n      `  EXECUTE IMMEDIATE ('ALTER TABLE \"${tableName}\" RENAME COLUMN \"${columnName}\" TO \"${to}\"');` +\n      `  SELECT COUNT(*) INTO IS_AUTOINC from \"USER_TRIGGERS\" where trigger_name = '${triggerName}';` +\n      `  IF (IS_AUTOINC > 0) THEN` +\n      `    SELECT cols.column_name INTO PK_NAME` +\n      `    FROM all_constraints cons, all_cons_columns cols` +\n      `    WHERE cons.constraint_type = 'P'` +\n      `    AND cons.constraint_name = cols.constraint_name` +\n      `    AND cons.owner = cols.owner` +\n      `    AND cols.table_name = '${tableName}';` +\n      `    IF ('${to}' = PK_NAME) THEN` +\n      `      EXECUTE IMMEDIATE ('DROP TRIGGER \"${triggerName}\"');` +\n      `      EXECUTE IMMEDIATE ('create or replace trigger \"${triggerName}\"` +\n      `      BEFORE INSERT on \"${tableName}\" for each row` +\n      `        declare` +\n      `        checking number := 1;` +\n      `        begin` +\n      `          if (:new.\"${to}\" is null) then` +\n      `            while checking >= 1 loop` +\n      `              select \"${sequenceName}\".nextval into :new.\"${to}\" from dual;` +\n      `              select count(\"${to}\") into checking from \"${tableName}\"` +\n      `              where \"${to}\" = :new.\"${to}\";` +\n      `            end loop;` +\n      `          end if;` +\n      `        end;');` +\n      `    end if;` +\n      `  end if;` +\n      `END;`\n    );\n  },\n\n  createAutoIncrementTrigger: function (logger, tableName, schemaName) {\n    const tableQuoted = `\"${tableName}\"`;\n    const tableUnquoted = tableName;\n    const schemaQuoted = schemaName ? `\"${schemaName}\".` : '';\n    const constraintOwner = schemaName ? `'${schemaName}'` : 'cols.owner';\n    const triggerName = utils.generateCombinedName(\n      logger,\n      'autoinc_trg',\n      tableName\n    );\n    const sequenceNameUnquoted = utils.generateCombinedName(\n      logger,\n      'seq',\n      tableName\n    );\n    const sequenceNameQuoted = `\"${sequenceNameUnquoted}\"`;\n    return (\n      `DECLARE ` +\n      `PK_NAME VARCHAR(200); ` +\n      `BEGIN` +\n      `  EXECUTE IMMEDIATE ('CREATE SEQUENCE ${schemaQuoted}${sequenceNameQuoted}');` +\n      `  SELECT cols.column_name INTO PK_NAME` + // TODO : support autoincrement on table with multiple primary keys\n      `  FROM all_constraints cons, all_cons_columns cols` +\n      `  WHERE cons.constraint_type = 'P'` +\n      `  AND cons.constraint_name = cols.constraint_name` +\n      `  AND cons.owner = ${constraintOwner}` +\n      `  AND cols.table_name = '${tableUnquoted}';` +\n      `  execute immediate ('create or replace trigger ${schemaQuoted}\"${triggerName}\"` +\n      `  BEFORE INSERT on ${schemaQuoted}${tableQuoted}` +\n      `  for each row` +\n      `  declare` +\n      `  checking number := 1;` +\n      `  begin` +\n      `    if (:new.\"' || PK_NAME || '\" is null) then` +\n      `      while checking >= 1 loop` +\n      `        select ${schemaQuoted}${sequenceNameQuoted}.nextval into :new.\"' || PK_NAME || '\" from dual;` +\n      `        select count(\"' || PK_NAME || '\") into checking from ${schemaQuoted}${tableQuoted}` +\n      `        where \"' || PK_NAME || '\" = :new.\"' || PK_NAME || '\";` +\n      `      end loop;` +\n      `    end if;` +\n      `  end;'); ` +\n      `END;`\n    );\n  },\n\n  renameTableAndAutoIncrementTrigger: function (logger, tableName, to) {\n    const triggerName = utils.generateCombinedName(\n      logger,\n      'autoinc_trg',\n      tableName\n    );\n    const sequenceName = utils.generateCombinedName(logger, 'seq', tableName);\n    const toTriggerName = utils.generateCombinedName(logger, 'autoinc_trg', to);\n    const toSequenceName = utils.generateCombinedName(logger, 'seq', to);\n    return (\n      `DECLARE ` +\n      `PK_NAME VARCHAR(200); ` +\n      `IS_AUTOINC NUMBER := 0; ` +\n      `BEGIN` +\n      `  EXECUTE IMMEDIATE ('RENAME \"${tableName}\" TO \"${to}\"');` +\n      `  SELECT COUNT(*) INTO IS_AUTOINC from \"USER_TRIGGERS\" where trigger_name = '${triggerName}';` +\n      `  IF (IS_AUTOINC > 0) THEN` +\n      `    EXECUTE IMMEDIATE ('DROP TRIGGER \"${triggerName}\"');` +\n      `    EXECUTE IMMEDIATE ('RENAME \"${sequenceName}\" TO \"${toSequenceName}\"');` +\n      `    SELECT cols.column_name INTO PK_NAME` +\n      `    FROM all_constraints cons, all_cons_columns cols` +\n      `    WHERE cons.constraint_type = 'P'` +\n      `    AND cons.constraint_name = cols.constraint_name` +\n      `    AND cons.owner = cols.owner` +\n      `    AND cols.table_name = '${to}';` +\n      `    EXECUTE IMMEDIATE ('create or replace trigger \"${toTriggerName}\"` +\n      `    BEFORE INSERT on \"${to}\" for each row` +\n      `      declare` +\n      `      checking number := 1;` +\n      `      begin` +\n      `        if (:new.\"' || PK_NAME || '\" is null) then` +\n      `          while checking >= 1 loop` +\n      `            select \"${toSequenceName}\".nextval into :new.\"' || PK_NAME || '\" from dual;` +\n      `            select count(\"' || PK_NAME || '\") into checking from \"${to}\"` +\n      `            where \"' || PK_NAME || '\" = :new.\"' || PK_NAME || '\";` +\n      `          end loop;` +\n      `        end if;` +\n      `      end;');` +\n      `  end if;` +\n      `END;`\n    );\n  },\n};\n\nmodule.exports = trigger;\n"],"mappings":"AAAA,MAAMA,KAAK,GAAGC,OAAO,CAAC,aAAa,CAAC;AAEpC,MAAMC,OAAO,GAAG;EACdC,mBAAmB,EAAE,SAAAA,CAAUC,MAAM,EAAEC,SAAS,EAAEC,UAAU,EAAEC,EAAE,EAAE;IAChE,MAAMC,WAAW,GAAGR,KAAK,CAACS,oBAAoB,CAC5CL,MAAM,EACN,aAAa,EACbC,SACF,CAAC;IACD,MAAMK,YAAY,GAAGV,KAAK,CAACS,oBAAoB,CAACL,MAAM,EAAE,KAAK,EAAEC,SAAS,CAAC;IACzE,OACG,UAAS,GACT,wBAAuB,GACvB,0BAAyB,GACzB,OAAM,GACN,sCAAqCA,SAAU,oBAAmBC,UAAW,SAAQC,EAAG,MAAK,GAC7F,gFAA+EC,WAAY,IAAG,GAC9F,4BAA2B,GAC3B,0CAAyC,GACzC,sDAAqD,GACrD,sCAAqC,GACrC,qDAAoD,GACpD,iCAAgC,GAChC,8BAA6BH,SAAU,IAAG,GAC1C,YAAWE,EAAG,mBAAkB,GAChC,2CAA0CC,WAAY,MAAK,GAC3D,wDAAuDA,WAAY,GAAE,GACrE,2BAA0BH,SAAU,gBAAe,GACnD,iBAAgB,GAChB,+BAA8B,GAC9B,eAAc,GACd,uBAAsBE,EAAG,iBAAgB,GACzC,sCAAqC,GACrC,yBAAwBG,YAAa,wBAAuBH,EAAG,cAAa,GAC5E,+BAA8BA,EAAG,0BAAyBF,SAAU,GAAE,GACtE,wBAAuBE,EAAG,aAAYA,EAAG,IAAG,GAC5C,uBAAsB,GACtB,mBAAkB,GAClB,iBAAgB,GAChB,aAAY,GACZ,WAAU,GACV,MAAK;EAEV,CAAC;EAEDI,0BAA0B,EAAE,SAAAA,CAAUP,MAAM,EAAEC,SAAS,EAAEO,UAAU,EAAE;IACnE,MAAMC,WAAW,GAAI,IAAGR,SAAU,GAAE;IACpC,MAAMS,aAAa,GAAGT,SAAS;IAC/B,MAAMU,YAAY,GAAGH,UAAU,GAAI,IAAGA,UAAW,IAAG,GAAG,EAAE;IACzD,MAAMI,eAAe,GAAGJ,UAAU,GAAI,IAAGA,UAAW,GAAE,GAAG,YAAY;IACrE,MAAMJ,WAAW,GAAGR,KAAK,CAACS,oBAAoB,CAC5CL,MAAM,EACN,aAAa,EACbC,SACF,CAAC;IACD,MAAMY,oBAAoB,GAAGjB,KAAK,CAACS,oBAAoB,CACrDL,MAAM,EACN,KAAK,EACLC,SACF,CAAC;IACD,MAAMa,kBAAkB,GAAI,IAAGD,oBAAqB,GAAE;IACtD,OACG,UAAS,GACT,wBAAuB,GACvB,OAAM,GACN,yCAAwCF,YAAa,GAAEG,kBAAmB,KAAI,GAC9E,wCAAuC;IAAG;IAC1C,oDAAmD,GACnD,oCAAmC,GACnC,mDAAkD,GAClD,sBAAqBF,eAAgB,EAAC,GACtC,4BAA2BF,aAAc,IAAG,GAC5C,mDAAkDC,YAAa,IAAGP,WAAY,GAAE,GAChF,sBAAqBO,YAAa,GAAEF,WAAY,EAAC,GACjD,gBAAe,GACf,WAAU,GACV,yBAAwB,GACxB,SAAQ,GACR,gDAA+C,GAC/C,gCAA+B,GAC/B,kBAAiBE,YAAa,GAAEG,kBAAmB,mDAAkD,GACrG,gEAA+DH,YAAa,GAAEF,WAAY,EAAC,GAC3F,+DAA8D,GAC9D,iBAAgB,GAChB,aAAY,GACZ,YAAW,GACX,MAAK;EAEV,CAAC;EAEDM,kCAAkC,EAAE,SAAAA,CAAUf,MAAM,EAAEC,SAAS,EAAEE,EAAE,EAAE;IACnE,MAAMC,WAAW,GAAGR,KAAK,CAACS,oBAAoB,CAC5CL,MAAM,EACN,aAAa,EACbC,SACF,CAAC;IACD,MAAMK,YAAY,GAAGV,KAAK,CAACS,oBAAoB,CAACL,MAAM,EAAE,KAAK,EAAEC,SAAS,CAAC;IACzE,MAAMe,aAAa,GAAGpB,KAAK,CAACS,oBAAoB,CAACL,MAAM,EAAE,aAAa,EAAEG,EAAE,CAAC;IAC3E,MAAMc,cAAc,GAAGrB,KAAK,CAACS,oBAAoB,CAACL,MAAM,EAAE,KAAK,EAAEG,EAAE,CAAC;IACpE,OACG,UAAS,GACT,wBAAuB,GACvB,0BAAyB,GACzB,OAAM,GACN,iCAAgCF,SAAU,SAAQE,EAAG,MAAK,GAC1D,gFAA+EC,WAAY,IAAG,GAC9F,4BAA2B,GAC3B,yCAAwCA,WAAY,MAAK,GACzD,mCAAkCE,YAAa,SAAQW,cAAe,MAAK,GAC3E,0CAAyC,GACzC,sDAAqD,GACrD,sCAAqC,GACrC,qDAAoD,GACpD,iCAAgC,GAChC,8BAA6Bd,EAAG,IAAG,GACnC,sDAAqDa,aAAc,GAAE,GACrE,yBAAwBb,EAAG,gBAAe,GAC1C,eAAc,GACd,6BAA4B,GAC5B,aAAY,GACZ,oDAAmD,GACnD,oCAAmC,GACnC,uBAAsBc,cAAe,oDAAmD,GACxF,qEAAoEd,EAAG,GAAE,GACzE,mEAAkE,GAClE,qBAAoB,GACpB,iBAAgB,GAChB,eAAc,GACd,WAAU,GACV,MAAK;EAEV;AACF,CAAC;AAEDe,MAAM,CAACC,OAAO,GAAGrB,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}