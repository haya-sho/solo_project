{"ast":null,"code":"// PostgreSQL Schema Compiler\n// -------\n\nconst SchemaCompiler = require('../../../schema/compiler');\nclass SchemaCompiler_PG extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  }\n\n  // Check whether the current table\n  hasTable(tableName) {\n    let sql = 'select * from information_schema.tables where table_name = ?';\n    const bindings = [tableName];\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      }\n    });\n  }\n\n  // Compile the query to determine if a column exists in a table.\n  hasColumn(tableName, columnName) {\n    let sql = 'select * from information_schema.columns where table_name = ? and column_name = ?';\n    const bindings = [tableName, columnName];\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      }\n    });\n  }\n  qualifiedTableName(tableName) {\n    const name = this.schema ? `${this.schema}.${tableName}` : tableName;\n    return this.formatter.wrap(name);\n  }\n\n  // Compile a rename table command.\n  renameTable(from, to) {\n    this.pushQuery(`alter table ${this.qualifiedTableName(from)} rename to ${this.formatter.wrap(to)}`);\n  }\n  createSchema(schemaName) {\n    this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);\n  }\n  createSchemaIfNotExists(schemaName) {\n    this.pushQuery(`create schema if not exists ${this.formatter.wrap(schemaName)}`);\n  }\n  dropSchema(schemaName) {\n    let cascade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.pushQuery(`drop schema ${this.formatter.wrap(schemaName)}${cascade ? ' cascade' : ''}`);\n  }\n  dropSchemaIfExists(schemaName) {\n    let cascade = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.pushQuery(`drop schema if exists ${this.formatter.wrap(schemaName)}${cascade ? ' cascade' : ''}`);\n  }\n  dropExtension(extensionName) {\n    this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);\n  }\n  dropExtensionIfExists(extensionName) {\n    this.pushQuery(`drop extension if exists ${this.formatter.wrap(extensionName)}`);\n  }\n  createExtension(extensionName) {\n    this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);\n  }\n  createExtensionIfNotExists(extensionName) {\n    this.pushQuery(`create extension if not exists ${this.formatter.wrap(extensionName)}`);\n  }\n  renameView(from, to) {\n    this.pushQuery(this.alterViewPrefix + `${this.formatter.wrap(from)} rename to ${this.formatter.wrap(to)}`);\n  }\n  refreshMaterializedView(viewName) {\n    let concurrently = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.pushQuery({\n      sql: `refresh materialized view${concurrently ? ' concurrently' : ''} ${this.formatter.wrap(viewName)}`\n    });\n  }\n  dropMaterializedView(viewName) {\n    this._dropView(viewName, false, true);\n  }\n  dropMaterializedViewIfExists(viewName) {\n    this._dropView(viewName, true, true);\n  }\n}\nmodule.exports = SchemaCompiler_PG;","map":{"version":3,"names":["SchemaCompiler","require","SchemaCompiler_PG","constructor","client","builder","hasTable","tableName","sql","bindings","schema","push","pushQuery","output","resp","rows","length","hasColumn","columnName","qualifiedTableName","name","formatter","wrap","renameTable","from","to","createSchema","schemaName","createSchemaIfNotExists","dropSchema","cascade","arguments","undefined","dropSchemaIfExists","dropExtension","extensionName","dropExtensionIfExists","createExtension","createExtensionIfNotExists","renameView","alterViewPrefix","refreshMaterializedView","viewName","concurrently","dropMaterializedView","_dropView","dropMaterializedViewIfExists","module","exports"],"sources":["/Users/user/dig_develop/solo_project/node_modules/knex/lib/dialects/postgres/schema/pg-compiler.js"],"sourcesContent":["// PostgreSQL Schema Compiler\n// -------\n\nconst SchemaCompiler = require('../../../schema/compiler');\n\nclass SchemaCompiler_PG extends SchemaCompiler {\n  constructor(client, builder) {\n    super(client, builder);\n  }\n\n  // Check whether the current table\n  hasTable(tableName) {\n    let sql = 'select * from information_schema.tables where table_name = ?';\n    const bindings = [tableName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      },\n    });\n  }\n\n  // Compile the query to determine if a column exists in a table.\n  hasColumn(tableName, columnName) {\n    let sql =\n      'select * from information_schema.columns where table_name = ? and column_name = ?';\n    const bindings = [tableName, columnName];\n\n    if (this.schema) {\n      sql += ' and table_schema = ?';\n      bindings.push(this.schema);\n    } else {\n      sql += ' and table_schema = current_schema()';\n    }\n\n    this.pushQuery({\n      sql,\n      bindings,\n      output(resp) {\n        return resp.rows.length > 0;\n      },\n    });\n  }\n\n  qualifiedTableName(tableName) {\n    const name = this.schema ? `${this.schema}.${tableName}` : tableName;\n    return this.formatter.wrap(name);\n  }\n\n  // Compile a rename table command.\n  renameTable(from, to) {\n    this.pushQuery(\n      `alter table ${this.qualifiedTableName(\n        from\n      )} rename to ${this.formatter.wrap(to)}`\n    );\n  }\n\n  createSchema(schemaName) {\n    this.pushQuery(`create schema ${this.formatter.wrap(schemaName)}`);\n  }\n\n  createSchemaIfNotExists(schemaName) {\n    this.pushQuery(\n      `create schema if not exists ${this.formatter.wrap(schemaName)}`\n    );\n  }\n\n  dropSchema(schemaName, cascade = false) {\n    this.pushQuery(\n      `drop schema ${this.formatter.wrap(schemaName)}${\n        cascade ? ' cascade' : ''\n      }`\n    );\n  }\n\n  dropSchemaIfExists(schemaName, cascade = false) {\n    this.pushQuery(\n      `drop schema if exists ${this.formatter.wrap(schemaName)}${\n        cascade ? ' cascade' : ''\n      }`\n    );\n  }\n\n  dropExtension(extensionName) {\n    this.pushQuery(`drop extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  dropExtensionIfExists(extensionName) {\n    this.pushQuery(\n      `drop extension if exists ${this.formatter.wrap(extensionName)}`\n    );\n  }\n\n  createExtension(extensionName) {\n    this.pushQuery(`create extension ${this.formatter.wrap(extensionName)}`);\n  }\n\n  createExtensionIfNotExists(extensionName) {\n    this.pushQuery(\n      `create extension if not exists ${this.formatter.wrap(extensionName)}`\n    );\n  }\n\n  renameView(from, to) {\n    this.pushQuery(\n      this.alterViewPrefix +\n        `${this.formatter.wrap(from)} rename to ${this.formatter.wrap(to)}`\n    );\n  }\n\n  refreshMaterializedView(viewName, concurrently = false) {\n    this.pushQuery({\n      sql: `refresh materialized view${\n        concurrently ? ' concurrently' : ''\n      } ${this.formatter.wrap(viewName)}`,\n    });\n  }\n\n  dropMaterializedView(viewName) {\n    this._dropView(viewName, false, true);\n  }\n\n  dropMaterializedViewIfExists(viewName) {\n    this._dropView(viewName, true, true);\n  }\n}\n\nmodule.exports = SchemaCompiler_PG;\n"],"mappings":"AAAA;AACA;;AAEA,MAAMA,cAAc,GAAGC,OAAO,CAAC,0BAA0B,CAAC;AAE1D,MAAMC,iBAAiB,SAASF,cAAc,CAAC;EAC7CG,WAAWA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC3B,KAAK,CAACD,MAAM,EAAEC,OAAO,CAAC;EACxB;;EAEA;EACAC,QAAQA,CAACC,SAAS,EAAE;IAClB,IAAIC,GAAG,GAAG,8DAA8D;IACxE,MAAMC,QAAQ,GAAG,CAACF,SAAS,CAAC;IAE5B,IAAI,IAAI,CAACG,MAAM,EAAE;MACfF,GAAG,IAAI,uBAAuB;MAC9BC,QAAQ,CAACE,IAAI,CAAC,IAAI,CAACD,MAAM,CAAC;IAC5B,CAAC,MAAM;MACLF,GAAG,IAAI,sCAAsC;IAC/C;IAEA,IAAI,CAACI,SAAS,CAAC;MACbJ,GAAG;MACHC,QAAQ;MACRI,MAAMA,CAACC,IAAI,EAAE;QACX,OAAOA,IAAI,CAACC,IAAI,CAACC,MAAM,GAAG,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ;;EAEA;EACAC,SAASA,CAACV,SAAS,EAAEW,UAAU,EAAE;IAC/B,IAAIV,GAAG,GACL,mFAAmF;IACrF,MAAMC,QAAQ,GAAG,CAACF,SAAS,EAAEW,UAAU,CAAC;IAExC,IAAI,IAAI,CAACR,MAAM,EAAE;MACfF,GAAG,IAAI,uBAAuB;MAC9BC,QAAQ,CAACE,IAAI,CAAC,IAAI,CAACD,MAAM,CAAC;IAC5B,CAAC,MAAM;MACLF,GAAG,IAAI,sCAAsC;IAC/C;IAEA,IAAI,CAACI,SAAS,CAAC;MACbJ,GAAG;MACHC,QAAQ;MACRI,MAAMA,CAACC,IAAI,EAAE;QACX,OAAOA,IAAI,CAACC,IAAI,CAACC,MAAM,GAAG,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ;EAEAG,kBAAkBA,CAACZ,SAAS,EAAE;IAC5B,MAAMa,IAAI,GAAG,IAAI,CAACV,MAAM,GAAI,GAAE,IAAI,CAACA,MAAO,IAAGH,SAAU,EAAC,GAAGA,SAAS;IACpE,OAAO,IAAI,CAACc,SAAS,CAACC,IAAI,CAACF,IAAI,CAAC;EAClC;;EAEA;EACAG,WAAWA,CAACC,IAAI,EAAEC,EAAE,EAAE;IACpB,IAAI,CAACb,SAAS,CACX,eAAc,IAAI,CAACO,kBAAkB,CACpCK,IACF,CAAE,cAAa,IAAI,CAACH,SAAS,CAACC,IAAI,CAACG,EAAE,CAAE,EACzC,CAAC;EACH;EAEAC,YAAYA,CAACC,UAAU,EAAE;IACvB,IAAI,CAACf,SAAS,CAAE,iBAAgB,IAAI,CAACS,SAAS,CAACC,IAAI,CAACK,UAAU,CAAE,EAAC,CAAC;EACpE;EAEAC,uBAAuBA,CAACD,UAAU,EAAE;IAClC,IAAI,CAACf,SAAS,CACX,+BAA8B,IAAI,CAACS,SAAS,CAACC,IAAI,CAACK,UAAU,CAAE,EACjE,CAAC;EACH;EAEAE,UAAUA,CAACF,UAAU,EAAmB;IAAA,IAAjBG,OAAO,GAAAC,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACpC,IAAI,CAACnB,SAAS,CACX,eAAc,IAAI,CAACS,SAAS,CAACC,IAAI,CAACK,UAAU,CAAE,GAC7CG,OAAO,GAAG,UAAU,GAAG,EACxB,EACH,CAAC;EACH;EAEAG,kBAAkBA,CAACN,UAAU,EAAmB;IAAA,IAAjBG,OAAO,GAAAC,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IAC5C,IAAI,CAACnB,SAAS,CACX,yBAAwB,IAAI,CAACS,SAAS,CAACC,IAAI,CAACK,UAAU,CAAE,GACvDG,OAAO,GAAG,UAAU,GAAG,EACxB,EACH,CAAC;EACH;EAEAI,aAAaA,CAACC,aAAa,EAAE;IAC3B,IAAI,CAACvB,SAAS,CAAE,kBAAiB,IAAI,CAACS,SAAS,CAACC,IAAI,CAACa,aAAa,CAAE,EAAC,CAAC;EACxE;EAEAC,qBAAqBA,CAACD,aAAa,EAAE;IACnC,IAAI,CAACvB,SAAS,CACX,4BAA2B,IAAI,CAACS,SAAS,CAACC,IAAI,CAACa,aAAa,CAAE,EACjE,CAAC;EACH;EAEAE,eAAeA,CAACF,aAAa,EAAE;IAC7B,IAAI,CAACvB,SAAS,CAAE,oBAAmB,IAAI,CAACS,SAAS,CAACC,IAAI,CAACa,aAAa,CAAE,EAAC,CAAC;EAC1E;EAEAG,0BAA0BA,CAACH,aAAa,EAAE;IACxC,IAAI,CAACvB,SAAS,CACX,kCAAiC,IAAI,CAACS,SAAS,CAACC,IAAI,CAACa,aAAa,CAAE,EACvE,CAAC;EACH;EAEAI,UAAUA,CAACf,IAAI,EAAEC,EAAE,EAAE;IACnB,IAAI,CAACb,SAAS,CACZ,IAAI,CAAC4B,eAAe,GACjB,GAAE,IAAI,CAACnB,SAAS,CAACC,IAAI,CAACE,IAAI,CAAE,cAAa,IAAI,CAACH,SAAS,CAACC,IAAI,CAACG,EAAE,CAAE,EACtE,CAAC;EACH;EAEAgB,uBAAuBA,CAACC,QAAQ,EAAwB;IAAA,IAAtBC,YAAY,GAAAZ,SAAA,CAAAf,MAAA,QAAAe,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACpD,IAAI,CAACnB,SAAS,CAAC;MACbJ,GAAG,EAAG,4BACJmC,YAAY,GAAG,eAAe,GAAG,EAClC,IAAG,IAAI,CAACtB,SAAS,CAACC,IAAI,CAACoB,QAAQ,CAAE;IACpC,CAAC,CAAC;EACJ;EAEAE,oBAAoBA,CAACF,QAAQ,EAAE;IAC7B,IAAI,CAACG,SAAS,CAACH,QAAQ,EAAE,KAAK,EAAE,IAAI,CAAC;EACvC;EAEAI,4BAA4BA,CAACJ,QAAQ,EAAE;IACrC,IAAI,CAACG,SAAS,CAACH,QAAQ,EAAE,IAAI,EAAE,IAAI,CAAC;EACtC;AACF;AAEAK,MAAM,CAACC,OAAO,GAAG9C,iBAAiB"},"metadata":{},"sourceType":"script","externalDependencies":[]}